
Led-Strip.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001e40  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000003c  08001f00  08001f00  00011f00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08001f3c  08001f3c  00020004  2**0
                  CONTENTS
  4 .ARM          00000000  08001f3c  08001f3c  00020004  2**0
                  CONTENTS
  5 .preinit_array 00000000  08001f3c  08001f3c  00020004  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08001f3c  08001f3c  00011f3c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08001f40  08001f40  00011f40  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000004  20000000  08001f44  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000000d0  20000004  08001f48  00020004  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200000d4  08001f48  000200d4  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00020004  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001227a  00000000  00000000  0002002c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000023f1  00000000  00000000  000322a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000a57d  00000000  00000000  00034697  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000820  00000000  00000000  0003ec18  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000016d0  00000000  00000000  0003f438  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  000183c8  00000000  00000000  00040b08  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   00009cbe  00000000  00000000  00058ed0  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    0007d44e  00000000  00000000  00062b8e  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  000dffdc  2**0
                  CONTENTS, READONLY
 21 .debug_frame  000018c8  00000000  00000000  000e0058  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000004 	.word	0x20000004
 80000e0:	00000000 	.word	0x00000000
 80000e4:	08001ee8 	.word	0x08001ee8

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000008 	.word	0x20000008
 8000104:	08001ee8 	.word	0x08001ee8

08000108 <__udivsi3>:
 8000108:	2200      	movs	r2, #0
 800010a:	0843      	lsrs	r3, r0, #1
 800010c:	428b      	cmp	r3, r1
 800010e:	d374      	bcc.n	80001fa <__udivsi3+0xf2>
 8000110:	0903      	lsrs	r3, r0, #4
 8000112:	428b      	cmp	r3, r1
 8000114:	d35f      	bcc.n	80001d6 <__udivsi3+0xce>
 8000116:	0a03      	lsrs	r3, r0, #8
 8000118:	428b      	cmp	r3, r1
 800011a:	d344      	bcc.n	80001a6 <__udivsi3+0x9e>
 800011c:	0b03      	lsrs	r3, r0, #12
 800011e:	428b      	cmp	r3, r1
 8000120:	d328      	bcc.n	8000174 <__udivsi3+0x6c>
 8000122:	0c03      	lsrs	r3, r0, #16
 8000124:	428b      	cmp	r3, r1
 8000126:	d30d      	bcc.n	8000144 <__udivsi3+0x3c>
 8000128:	22ff      	movs	r2, #255	; 0xff
 800012a:	0209      	lsls	r1, r1, #8
 800012c:	ba12      	rev	r2, r2
 800012e:	0c03      	lsrs	r3, r0, #16
 8000130:	428b      	cmp	r3, r1
 8000132:	d302      	bcc.n	800013a <__udivsi3+0x32>
 8000134:	1212      	asrs	r2, r2, #8
 8000136:	0209      	lsls	r1, r1, #8
 8000138:	d065      	beq.n	8000206 <__udivsi3+0xfe>
 800013a:	0b03      	lsrs	r3, r0, #12
 800013c:	428b      	cmp	r3, r1
 800013e:	d319      	bcc.n	8000174 <__udivsi3+0x6c>
 8000140:	e000      	b.n	8000144 <__udivsi3+0x3c>
 8000142:	0a09      	lsrs	r1, r1, #8
 8000144:	0bc3      	lsrs	r3, r0, #15
 8000146:	428b      	cmp	r3, r1
 8000148:	d301      	bcc.n	800014e <__udivsi3+0x46>
 800014a:	03cb      	lsls	r3, r1, #15
 800014c:	1ac0      	subs	r0, r0, r3
 800014e:	4152      	adcs	r2, r2
 8000150:	0b83      	lsrs	r3, r0, #14
 8000152:	428b      	cmp	r3, r1
 8000154:	d301      	bcc.n	800015a <__udivsi3+0x52>
 8000156:	038b      	lsls	r3, r1, #14
 8000158:	1ac0      	subs	r0, r0, r3
 800015a:	4152      	adcs	r2, r2
 800015c:	0b43      	lsrs	r3, r0, #13
 800015e:	428b      	cmp	r3, r1
 8000160:	d301      	bcc.n	8000166 <__udivsi3+0x5e>
 8000162:	034b      	lsls	r3, r1, #13
 8000164:	1ac0      	subs	r0, r0, r3
 8000166:	4152      	adcs	r2, r2
 8000168:	0b03      	lsrs	r3, r0, #12
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x6a>
 800016e:	030b      	lsls	r3, r1, #12
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0ac3      	lsrs	r3, r0, #11
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x76>
 800017a:	02cb      	lsls	r3, r1, #11
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0a83      	lsrs	r3, r0, #10
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x82>
 8000186:	028b      	lsls	r3, r1, #10
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0a43      	lsrs	r3, r0, #9
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x8e>
 8000192:	024b      	lsls	r3, r1, #9
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0a03      	lsrs	r3, r0, #8
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x9a>
 800019e:	020b      	lsls	r3, r1, #8
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	d2cd      	bcs.n	8000142 <__udivsi3+0x3a>
 80001a6:	09c3      	lsrs	r3, r0, #7
 80001a8:	428b      	cmp	r3, r1
 80001aa:	d301      	bcc.n	80001b0 <__udivsi3+0xa8>
 80001ac:	01cb      	lsls	r3, r1, #7
 80001ae:	1ac0      	subs	r0, r0, r3
 80001b0:	4152      	adcs	r2, r2
 80001b2:	0983      	lsrs	r3, r0, #6
 80001b4:	428b      	cmp	r3, r1
 80001b6:	d301      	bcc.n	80001bc <__udivsi3+0xb4>
 80001b8:	018b      	lsls	r3, r1, #6
 80001ba:	1ac0      	subs	r0, r0, r3
 80001bc:	4152      	adcs	r2, r2
 80001be:	0943      	lsrs	r3, r0, #5
 80001c0:	428b      	cmp	r3, r1
 80001c2:	d301      	bcc.n	80001c8 <__udivsi3+0xc0>
 80001c4:	014b      	lsls	r3, r1, #5
 80001c6:	1ac0      	subs	r0, r0, r3
 80001c8:	4152      	adcs	r2, r2
 80001ca:	0903      	lsrs	r3, r0, #4
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xcc>
 80001d0:	010b      	lsls	r3, r1, #4
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	08c3      	lsrs	r3, r0, #3
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xd8>
 80001dc:	00cb      	lsls	r3, r1, #3
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0883      	lsrs	r3, r0, #2
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xe4>
 80001e8:	008b      	lsls	r3, r1, #2
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0843      	lsrs	r3, r0, #1
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xf0>
 80001f4:	004b      	lsls	r3, r1, #1
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	1a41      	subs	r1, r0, r1
 80001fc:	d200      	bcs.n	8000200 <__udivsi3+0xf8>
 80001fe:	4601      	mov	r1, r0
 8000200:	4152      	adcs	r2, r2
 8000202:	4610      	mov	r0, r2
 8000204:	4770      	bx	lr
 8000206:	e7ff      	b.n	8000208 <__udivsi3+0x100>
 8000208:	b501      	push	{r0, lr}
 800020a:	2000      	movs	r0, #0
 800020c:	f000 f806 	bl	800021c <__aeabi_idiv0>
 8000210:	bd02      	pop	{r1, pc}
 8000212:	46c0      	nop			; (mov r8, r8)

08000214 <__aeabi_uidivmod>:
 8000214:	2900      	cmp	r1, #0
 8000216:	d0f7      	beq.n	8000208 <__udivsi3+0x100>
 8000218:	e776      	b.n	8000108 <__udivsi3>
 800021a:	4770      	bx	lr

0800021c <__aeabi_idiv0>:
 800021c:	4770      	bx	lr
 800021e:	46c0      	nop			; (mov r8, r8)

08000220 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000220:	b510      	push	{r4, lr}
 8000222:	0004      	movs	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000U);
 8000224:	f000 fd6a 	bl	8000cfc <HAL_RCC_GetHCLKFreq>
 8000228:	21fa      	movs	r1, #250	; 0xfa
 800022a:	0089      	lsls	r1, r1, #2
 800022c:	f7ff ff6c 	bl	8000108 <__udivsi3>
 8000230:	f000 f864 	bl	80002fc <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8000234:	2001      	movs	r0, #1
 8000236:	2200      	movs	r2, #0
 8000238:	0021      	movs	r1, r4
 800023a:	4240      	negs	r0, r0
 800023c:	f000 f832 	bl	80002a4 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 8000240:	2000      	movs	r0, #0
 8000242:	bd10      	pop	{r4, pc}

08000244 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000244:	2110      	movs	r1, #16
 8000246:	4a06      	ldr	r2, [pc, #24]	; (8000260 <HAL_Init+0x1c>)
{
 8000248:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800024a:	6813      	ldr	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 800024c:	2000      	movs	r0, #0
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800024e:	430b      	orrs	r3, r1
 8000250:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 8000252:	f7ff ffe5 	bl	8000220 <HAL_InitTick>
  HAL_MspInit();
 8000256:	f001 fd31 	bl	8001cbc <HAL_MspInit>
}
 800025a:	2000      	movs	r0, #0
 800025c:	bd10      	pop	{r4, pc}
 800025e:	46c0      	nop			; (mov r8, r8)
 8000260:	40022000 	.word	0x40022000

08000264 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000264:	4a02      	ldr	r2, [pc, #8]	; (8000270 <HAL_IncTick+0xc>)
 8000266:	6813      	ldr	r3, [r2, #0]
 8000268:	3301      	adds	r3, #1
 800026a:	6013      	str	r3, [r2, #0]
}
 800026c:	4770      	bx	lr
 800026e:	46c0      	nop			; (mov r8, r8)
 8000270:	200000d0 	.word	0x200000d0

08000274 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000274:	4b01      	ldr	r3, [pc, #4]	; (800027c <HAL_GetTick+0x8>)
 8000276:	6818      	ldr	r0, [r3, #0]
}
 8000278:	4770      	bx	lr
 800027a:	46c0      	nop			; (mov r8, r8)
 800027c:	200000d0 	.word	0x200000d0

08000280 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8000280:	b530      	push	{r4, r5, lr}
 8000282:	b083      	sub	sp, #12
 8000284:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8000286:	f7ff fff5 	bl	8000274 <HAL_GetTick>
  uint32_t wait = Delay;
 800028a:	9c01      	ldr	r4, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 800028c:	0005      	movs	r5, r0
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
  {
     wait++;
 800028e:	1c63      	adds	r3, r4, #1
 8000290:	1e5a      	subs	r2, r3, #1
 8000292:	4193      	sbcs	r3, r2
 8000294:	18e4      	adds	r4, r4, r3
  }
  
  while((HAL_GetTick() - tickstart) < wait)
 8000296:	f7ff ffed 	bl	8000274 <HAL_GetTick>
 800029a:	1b40      	subs	r0, r0, r5
 800029c:	42a0      	cmp	r0, r4
 800029e:	d3fa      	bcc.n	8000296 <HAL_Delay+0x16>
  {
  }
}
 80002a0:	b003      	add	sp, #12
 80002a2:	bd30      	pop	{r4, r5, pc}

080002a4 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80002a4:	22ff      	movs	r2, #255	; 0xff
 80002a6:	2303      	movs	r3, #3
 80002a8:	b530      	push	{r4, r5, lr}
 80002aa:	0014      	movs	r4, r2
 80002ac:	b2c5      	uxtb	r5, r0
 80002ae:	402b      	ands	r3, r5
 80002b0:	00db      	lsls	r3, r3, #3
 80002b2:	409c      	lsls	r4, r3
 80002b4:	0189      	lsls	r1, r1, #6
 80002b6:	400a      	ands	r2, r1
 80002b8:	43e4      	mvns	r4, r4
 80002ba:	409a      	lsls	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 80002bc:	2800      	cmp	r0, #0
 80002be:	db0b      	blt.n	80002d8 <HAL_NVIC_SetPriority+0x34>
 80002c0:	4b0c      	ldr	r3, [pc, #48]	; (80002f4 <HAL_NVIC_SetPriority+0x50>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80002c2:	0880      	lsrs	r0, r0, #2
 80002c4:	469c      	mov	ip, r3
 80002c6:	23c0      	movs	r3, #192	; 0xc0
 80002c8:	0080      	lsls	r0, r0, #2
 80002ca:	4460      	add	r0, ip
 80002cc:	009b      	lsls	r3, r3, #2
 80002ce:	58c1      	ldr	r1, [r0, r3]
 80002d0:	400c      	ands	r4, r1
 80002d2:	4322      	orrs	r2, r4
 80002d4:	50c2      	str	r2, [r0, r3]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 80002d6:	bd30      	pop	{r4, r5, pc}
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80002d8:	230f      	movs	r3, #15
 80002da:	4907      	ldr	r1, [pc, #28]	; (80002f8 <HAL_NVIC_SetPriority+0x54>)
 80002dc:	402b      	ands	r3, r5
 80002de:	468c      	mov	ip, r1
 80002e0:	3b08      	subs	r3, #8
 80002e2:	089b      	lsrs	r3, r3, #2
 80002e4:	009b      	lsls	r3, r3, #2
 80002e6:	4463      	add	r3, ip
 80002e8:	69d9      	ldr	r1, [r3, #28]
 80002ea:	400c      	ands	r4, r1
 80002ec:	4322      	orrs	r2, r4
 80002ee:	61da      	str	r2, [r3, #28]
 80002f0:	e7f1      	b.n	80002d6 <HAL_NVIC_SetPriority+0x32>
 80002f2:	46c0      	nop			; (mov r8, r8)
 80002f4:	e000e100 	.word	0xe000e100
 80002f8:	e000ed00 	.word	0xe000ed00

080002fc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80002fc:	4a0a      	ldr	r2, [pc, #40]	; (8000328 <HAL_SYSTICK_Config+0x2c>)
 80002fe:	1e43      	subs	r3, r0, #1
  {
    return (1UL);                                                   /* Reload value impossible */
 8000300:	2001      	movs	r0, #1
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000302:	4293      	cmp	r3, r2
 8000304:	d80e      	bhi.n	8000324 <HAL_SYSTICK_Config+0x28>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000306:	21c0      	movs	r1, #192	; 0xc0
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000308:	4a08      	ldr	r2, [pc, #32]	; (800032c <HAL_SYSTICK_Config+0x30>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800030a:	4809      	ldr	r0, [pc, #36]	; (8000330 <HAL_SYSTICK_Config+0x34>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800030c:	6053      	str	r3, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800030e:	6a03      	ldr	r3, [r0, #32]
 8000310:	0609      	lsls	r1, r1, #24
 8000312:	021b      	lsls	r3, r3, #8
 8000314:	0a1b      	lsrs	r3, r3, #8
 8000316:	430b      	orrs	r3, r1
 8000318:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800031a:	2300      	movs	r3, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800031c:	2000      	movs	r0, #0
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800031e:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000320:	3307      	adds	r3, #7
 8000322:	6013      	str	r3, [r2, #0]
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000324:	4770      	bx	lr
 8000326:	46c0      	nop			; (mov r8, r8)
 8000328:	00ffffff 	.word	0x00ffffff
 800032c:	e000e010 	.word	0xe000e010
 8000330:	e000ed00 	.word	0xe000ed00

08000334 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 8000334:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000336:	464e      	mov	r6, r9
 8000338:	46de      	mov	lr, fp
 800033a:	4657      	mov	r7, sl
 800033c:	4645      	mov	r5, r8
 800033e:	b5e0      	push	{r5, r6, r7, lr}
 8000340:	4689      	mov	r9, r1
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000342:	6809      	ldr	r1, [r1, #0]
{ 
 8000344:	b085      	sub	sp, #20
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000346:	2900      	cmp	r1, #0
 8000348:	d100      	bne.n	800034c <HAL_GPIO_Init+0x18>
 800034a:	e082      	b.n	8000452 <HAL_GPIO_Init+0x11e>
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800034c:	4b70      	ldr	r3, [pc, #448]	; (8000510 <HAL_GPIO_Init+0x1dc>)
  uint32_t position = 0x00U;
 800034e:	2200      	movs	r2, #0
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000350:	469b      	mov	fp, r3
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2] = temp;
                  
        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000352:	4b70      	ldr	r3, [pc, #448]	; (8000514 <HAL_GPIO_Init+0x1e0>)
 8000354:	468a      	mov	sl, r1
 8000356:	4698      	mov	r8, r3
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000358:	2501      	movs	r5, #1
 800035a:	4654      	mov	r4, sl
 800035c:	4095      	lsls	r5, r2
 800035e:	402c      	ands	r4, r5
 8000360:	9400      	str	r4, [sp, #0]
    if(iocurrent)
 8000362:	d072      	beq.n	800044a <HAL_GPIO_Init+0x116>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 8000364:	464b      	mov	r3, r9
 8000366:	6859      	ldr	r1, [r3, #4]
 8000368:	2310      	movs	r3, #16
 800036a:	000f      	movs	r7, r1
 800036c:	439f      	bics	r7, r3
 800036e:	9701      	str	r7, [sp, #4]
 8000370:	2f02      	cmp	r7, #2
 8000372:	d100      	bne.n	8000376 <HAL_GPIO_Init+0x42>
 8000374:	e074      	b.n	8000460 <HAL_GPIO_Init+0x12c>
      temp = GPIOx->MODER;
 8000376:	6803      	ldr	r3, [r0, #0]
 8000378:	0056      	lsls	r6, r2, #1
 800037a:	469c      	mov	ip, r3
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 800037c:	2303      	movs	r3, #3
 800037e:	40b3      	lsls	r3, r6
 8000380:	4664      	mov	r4, ip
 8000382:	43db      	mvns	r3, r3
 8000384:	401c      	ands	r4, r3
 8000386:	0027      	movs	r7, r4
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000388:	2403      	movs	r4, #3
 800038a:	400c      	ands	r4, r1
 800038c:	40b4      	lsls	r4, r6
 800038e:	46a4      	mov	ip, r4
 8000390:	003c      	movs	r4, r7
 8000392:	4667      	mov	r7, ip
 8000394:	433c      	orrs	r4, r7
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000396:	9f01      	ldr	r7, [sp, #4]
      GPIOx->MODER = temp;
 8000398:	6004      	str	r4, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800039a:	3f01      	subs	r7, #1
 800039c:	2f01      	cmp	r7, #1
 800039e:	d800      	bhi.n	80003a2 <HAL_GPIO_Init+0x6e>
 80003a0:	e07b      	b.n	800049a <HAL_GPIO_Init+0x166>
      temp = GPIOx->PUPDR;
 80003a2:	68c5      	ldr	r5, [r0, #12]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2U));
 80003a4:	402b      	ands	r3, r5
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 80003a6:	464d      	mov	r5, r9
 80003a8:	68ad      	ldr	r5, [r5, #8]
 80003aa:	40b5      	lsls	r5, r6
 80003ac:	432b      	orrs	r3, r5
      GPIOx->PUPDR = temp;
 80003ae:	60c3      	str	r3, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80003b0:	2380      	movs	r3, #128	; 0x80
 80003b2:	055b      	lsls	r3, r3, #21
 80003b4:	4219      	tst	r1, r3
 80003b6:	d048      	beq.n	800044a <HAL_GPIO_Init+0x116>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003b8:	465b      	mov	r3, fp
 80003ba:	2401      	movs	r4, #1
 80003bc:	465d      	mov	r5, fp
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80003be:	2603      	movs	r6, #3
 80003c0:	270f      	movs	r7, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003c2:	699b      	ldr	r3, [r3, #24]
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80003c4:	4016      	ands	r6, r2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003c6:	4323      	orrs	r3, r4
 80003c8:	61ab      	str	r3, [r5, #24]
 80003ca:	69ab      	ldr	r3, [r5, #24]
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80003cc:	00b6      	lsls	r6, r6, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003ce:	4023      	ands	r3, r4
 80003d0:	4c51      	ldr	r4, [pc, #324]	; (8000518 <HAL_GPIO_Init+0x1e4>)
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80003d2:	40b7      	lsls	r7, r6
 80003d4:	46a4      	mov	ip, r4
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80003d6:	2490      	movs	r4, #144	; 0x90
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003d8:	9303      	str	r3, [sp, #12]
 80003da:	9b03      	ldr	r3, [sp, #12]
        temp = SYSCFG->EXTICR[position >> 2];
 80003dc:	0893      	lsrs	r3, r2, #2
 80003de:	009b      	lsls	r3, r3, #2
 80003e0:	4463      	add	r3, ip
 80003e2:	689d      	ldr	r5, [r3, #8]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80003e4:	05e4      	lsls	r4, r4, #23
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80003e6:	43bd      	bics	r5, r7
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80003e8:	42a0      	cmp	r0, r4
 80003ea:	d012      	beq.n	8000412 <HAL_GPIO_Init+0xde>
 80003ec:	4f4b      	ldr	r7, [pc, #300]	; (800051c <HAL_GPIO_Init+0x1e8>)
 80003ee:	42b8      	cmp	r0, r7
 80003f0:	d100      	bne.n	80003f4 <HAL_GPIO_Init+0xc0>
 80003f2:	e080      	b.n	80004f6 <HAL_GPIO_Init+0x1c2>
 80003f4:	4f4a      	ldr	r7, [pc, #296]	; (8000520 <HAL_GPIO_Init+0x1ec>)
 80003f6:	42b8      	cmp	r0, r7
 80003f8:	d100      	bne.n	80003fc <HAL_GPIO_Init+0xc8>
 80003fa:	e078      	b.n	80004ee <HAL_GPIO_Init+0x1ba>
 80003fc:	4f49      	ldr	r7, [pc, #292]	; (8000524 <HAL_GPIO_Init+0x1f0>)
 80003fe:	42b8      	cmp	r0, r7
 8000400:	d100      	bne.n	8000404 <HAL_GPIO_Init+0xd0>
 8000402:	e07c      	b.n	80004fe <HAL_GPIO_Init+0x1ca>
 8000404:	4f48      	ldr	r7, [pc, #288]	; (8000528 <HAL_GPIO_Init+0x1f4>)
 8000406:	42b8      	cmp	r0, r7
 8000408:	d100      	bne.n	800040c <HAL_GPIO_Init+0xd8>
 800040a:	e07c      	b.n	8000506 <HAL_GPIO_Init+0x1d2>
 800040c:	2705      	movs	r7, #5
 800040e:	40b7      	lsls	r7, r6
 8000410:	433d      	orrs	r5, r7
        SYSCFG->EXTICR[position >> 2] = temp;
 8000412:	609d      	str	r5, [r3, #8]
        temp = EXTI->IMR;
 8000414:	4643      	mov	r3, r8
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8000416:	9c00      	ldr	r4, [sp, #0]
        temp = EXTI->IMR;
 8000418:	681b      	ldr	r3, [r3, #0]
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 800041a:	43e5      	mvns	r5, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800041c:	03cc      	lsls	r4, r1, #15
 800041e:	d44e      	bmi.n	80004be <HAL_GPIO_Init+0x18a>
        {
          SET_BIT(temp, iocurrent); 
        }
        EXTI->IMR = temp;
 8000420:	4644      	mov	r4, r8
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8000422:	402b      	ands	r3, r5
        EXTI->IMR = temp;
 8000424:	6023      	str	r3, [r4, #0]

        temp = EXTI->EMR;
 8000426:	6863      	ldr	r3, [r4, #4]
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000428:	038c      	lsls	r4, r1, #14
 800042a:	d44f      	bmi.n	80004cc <HAL_GPIO_Init+0x198>
        { 
          SET_BIT(temp, iocurrent); 
        }
        EXTI->EMR = temp;
 800042c:	4644      	mov	r4, r8
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
 800042e:	402b      	ands	r3, r5
        EXTI->EMR = temp;
 8000430:	6063      	str	r3, [r4, #4]
  
        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000432:	68a3      	ldr	r3, [r4, #8]
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000434:	02cc      	lsls	r4, r1, #11
 8000436:	d450      	bmi.n	80004da <HAL_GPIO_Init+0x1a6>
        {
          SET_BIT(temp, iocurrent); 
        }
        EXTI->RTSR = temp;
 8000438:	4644      	mov	r4, r8
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 800043a:	402b      	ands	r3, r5
        EXTI->RTSR = temp;
 800043c:	60a3      	str	r3, [r4, #8]

        temp = EXTI->FTSR;
 800043e:	68e3      	ldr	r3, [r4, #12]
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000440:	0289      	lsls	r1, r1, #10
 8000442:	d451      	bmi.n	80004e8 <HAL_GPIO_Init+0x1b4>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8000444:	402b      	ands	r3, r5
        {
          SET_BIT(temp, iocurrent); 
        }
        EXTI->FTSR = temp;
 8000446:	4641      	mov	r1, r8
 8000448:	60cb      	str	r3, [r1, #12]
  while (((GPIO_Init->Pin) >> position) != RESET)
 800044a:	4653      	mov	r3, sl
      }
    }
    
    position++;
 800044c:	3201      	adds	r2, #1
  while (((GPIO_Init->Pin) >> position) != RESET)
 800044e:	40d3      	lsrs	r3, r2
 8000450:	d182      	bne.n	8000358 <HAL_GPIO_Init+0x24>
  } 
}
 8000452:	b005      	add	sp, #20
 8000454:	bc3c      	pop	{r2, r3, r4, r5}
 8000456:	4690      	mov	r8, r2
 8000458:	4699      	mov	r9, r3
 800045a:	46a2      	mov	sl, r4
 800045c:	46ab      	mov	fp, r5
 800045e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 8000460:	2607      	movs	r6, #7
 8000462:	240f      	movs	r4, #15
 8000464:	4016      	ands	r6, r2
 8000466:	00b6      	lsls	r6, r6, #2
 8000468:	40b4      	lsls	r4, r6
        temp = GPIOx->AFR[position >> 3];
 800046a:	08d3      	lsrs	r3, r2, #3
 800046c:	009b      	lsls	r3, r3, #2
 800046e:	18c3      	adds	r3, r0, r3
 8000470:	6a1f      	ldr	r7, [r3, #32]
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 8000472:	43a7      	bics	r7, r4
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));       
 8000474:	464c      	mov	r4, r9
 8000476:	6924      	ldr	r4, [r4, #16]
 8000478:	40b4      	lsls	r4, r6
 800047a:	0026      	movs	r6, r4
 800047c:	433e      	orrs	r6, r7
        GPIOx->AFR[position >> 3U] = temp;
 800047e:	621e      	str	r6, [r3, #32]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 8000480:	2303      	movs	r3, #3
 8000482:	0056      	lsls	r6, r2, #1
 8000484:	40b3      	lsls	r3, r6
 8000486:	43db      	mvns	r3, r3
      temp = GPIOx->MODER;
 8000488:	6807      	ldr	r7, [r0, #0]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 800048a:	401f      	ands	r7, r3
 800048c:	46bc      	mov	ip, r7
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800048e:	2703      	movs	r7, #3
 8000490:	400f      	ands	r7, r1
 8000492:	40b7      	lsls	r7, r6
 8000494:	4664      	mov	r4, ip
 8000496:	4327      	orrs	r7, r4
      GPIOx->MODER = temp;
 8000498:	6007      	str	r7, [r0, #0]
        temp = GPIOx->OSPEEDR; 
 800049a:	6887      	ldr	r7, [r0, #8]
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 800049c:	464c      	mov	r4, r9
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 800049e:	401f      	ands	r7, r3
 80004a0:	46bc      	mov	ip, r7
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 80004a2:	68e7      	ldr	r7, [r4, #12]
 80004a4:	4664      	mov	r4, ip
 80004a6:	40b7      	lsls	r7, r6
 80004a8:	4327      	orrs	r7, r4
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80004aa:	2401      	movs	r4, #1
        GPIOx->OSPEEDR = temp;
 80004ac:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 80004ae:	6847      	ldr	r7, [r0, #4]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 80004b0:	43af      	bics	r7, r5
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80004b2:	090d      	lsrs	r5, r1, #4
 80004b4:	4025      	ands	r5, r4
 80004b6:	4095      	lsls	r5, r2
 80004b8:	433d      	orrs	r5, r7
        GPIOx->OTYPER = temp;
 80004ba:	6045      	str	r5, [r0, #4]
 80004bc:	e771      	b.n	80003a2 <HAL_GPIO_Init+0x6e>
          SET_BIT(temp, iocurrent); 
 80004be:	9c00      	ldr	r4, [sp, #0]
 80004c0:	4323      	orrs	r3, r4
        EXTI->IMR = temp;
 80004c2:	4644      	mov	r4, r8
 80004c4:	6023      	str	r3, [r4, #0]
        temp = EXTI->EMR;
 80004c6:	6863      	ldr	r3, [r4, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80004c8:	038c      	lsls	r4, r1, #14
 80004ca:	d5af      	bpl.n	800042c <HAL_GPIO_Init+0xf8>
          SET_BIT(temp, iocurrent); 
 80004cc:	9c00      	ldr	r4, [sp, #0]
 80004ce:	4323      	orrs	r3, r4
        EXTI->EMR = temp;
 80004d0:	4644      	mov	r4, r8
 80004d2:	6063      	str	r3, [r4, #4]
        temp = EXTI->RTSR;
 80004d4:	68a3      	ldr	r3, [r4, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80004d6:	02cc      	lsls	r4, r1, #11
 80004d8:	d5ae      	bpl.n	8000438 <HAL_GPIO_Init+0x104>
          SET_BIT(temp, iocurrent); 
 80004da:	9c00      	ldr	r4, [sp, #0]
 80004dc:	4323      	orrs	r3, r4
        EXTI->RTSR = temp;
 80004de:	4644      	mov	r4, r8
 80004e0:	60a3      	str	r3, [r4, #8]
        temp = EXTI->FTSR;
 80004e2:	68e3      	ldr	r3, [r4, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80004e4:	0289      	lsls	r1, r1, #10
 80004e6:	d5ad      	bpl.n	8000444 <HAL_GPIO_Init+0x110>
          SET_BIT(temp, iocurrent); 
 80004e8:	9900      	ldr	r1, [sp, #0]
 80004ea:	430b      	orrs	r3, r1
 80004ec:	e7ab      	b.n	8000446 <HAL_GPIO_Init+0x112>
 80004ee:	2702      	movs	r7, #2
 80004f0:	40b7      	lsls	r7, r6
 80004f2:	433d      	orrs	r5, r7
 80004f4:	e78d      	b.n	8000412 <HAL_GPIO_Init+0xde>
 80004f6:	2401      	movs	r4, #1
 80004f8:	40b4      	lsls	r4, r6
 80004fa:	4325      	orrs	r5, r4
 80004fc:	e789      	b.n	8000412 <HAL_GPIO_Init+0xde>
 80004fe:	2403      	movs	r4, #3
 8000500:	40b4      	lsls	r4, r6
 8000502:	4325      	orrs	r5, r4
 8000504:	e785      	b.n	8000412 <HAL_GPIO_Init+0xde>
 8000506:	2704      	movs	r7, #4
 8000508:	40b7      	lsls	r7, r6
 800050a:	433d      	orrs	r5, r7
 800050c:	e781      	b.n	8000412 <HAL_GPIO_Init+0xde>
 800050e:	46c0      	nop			; (mov r8, r8)
 8000510:	40021000 	.word	0x40021000
 8000514:	40010400 	.word	0x40010400
 8000518:	40010000 	.word	0x40010000
 800051c:	48000400 	.word	0x48000400
 8000520:	48000800 	.word	0x48000800
 8000524:	48000c00 	.word	0x48000c00
 8000528:	48001000 	.word	0x48001000

0800052c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800052c:	2a00      	cmp	r2, #0
 800052e:	d101      	bne.n	8000534 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8000530:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 8000532:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8000534:	6181      	str	r1, [r0, #24]
 8000536:	e7fc      	b.n	8000532 <HAL_GPIO_WritePin+0x6>

08000538 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000538:	b5f0      	push	{r4, r5, r6, r7, lr}
 800053a:	46ce      	mov	lr, r9
 800053c:	4647      	mov	r7, r8
 800053e:	b580      	push	{r7, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000540:	6803      	ldr	r3, [r0, #0]
{
 8000542:	b083      	sub	sp, #12
 8000544:	0004      	movs	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000546:	07da      	lsls	r2, r3, #31
 8000548:	d52f      	bpl.n	80005aa <HAL_RCC_OscConfig+0x72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 800054a:	210c      	movs	r1, #12
 800054c:	48c5      	ldr	r0, [pc, #788]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 800054e:	6842      	ldr	r2, [r0, #4]
 8000550:	400a      	ands	r2, r1
 8000552:	2a04      	cmp	r2, #4
 8000554:	d100      	bne.n	8000558 <HAL_RCC_OscConfig+0x20>
 8000556:	e104      	b.n	8000762 <HAL_RCC_OscConfig+0x22a>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8000558:	6842      	ldr	r2, [r0, #4]
 800055a:	4011      	ands	r1, r2
 800055c:	2908      	cmp	r1, #8
 800055e:	d100      	bne.n	8000562 <HAL_RCC_OscConfig+0x2a>
 8000560:	e0f6      	b.n	8000750 <HAL_RCC_OscConfig+0x218>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000562:	6863      	ldr	r3, [r4, #4]
 8000564:	2b01      	cmp	r3, #1
 8000566:	d100      	bne.n	800056a <HAL_RCC_OscConfig+0x32>
 8000568:	e135      	b.n	80007d6 <HAL_RCC_OscConfig+0x29e>
 800056a:	2b00      	cmp	r3, #0
 800056c:	d100      	bne.n	8000570 <HAL_RCC_OscConfig+0x38>
 800056e:	e169      	b.n	8000844 <HAL_RCC_OscConfig+0x30c>
 8000570:	2b05      	cmp	r3, #5
 8000572:	d100      	bne.n	8000576 <HAL_RCC_OscConfig+0x3e>
 8000574:	e228      	b.n	80009c8 <HAL_RCC_OscConfig+0x490>
 8000576:	4bbb      	ldr	r3, [pc, #748]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 8000578:	49bb      	ldr	r1, [pc, #748]	; (8000868 <HAL_RCC_OscConfig+0x330>)
 800057a:	681a      	ldr	r2, [r3, #0]
 800057c:	400a      	ands	r2, r1
 800057e:	601a      	str	r2, [r3, #0]
 8000580:	681a      	ldr	r2, [r3, #0]
 8000582:	49ba      	ldr	r1, [pc, #744]	; (800086c <HAL_RCC_OscConfig+0x334>)
 8000584:	400a      	ands	r2, r1
 8000586:	601a      	str	r2, [r3, #0]

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000588:	f7ff fe74 	bl	8000274 <HAL_GetTick>
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800058c:	2580      	movs	r5, #128	; 0x80
        tickstart = HAL_GetTick();
 800058e:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000590:	4eb4      	ldr	r6, [pc, #720]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 8000592:	02ad      	lsls	r5, r5, #10
 8000594:	e005      	b.n	80005a2 <HAL_RCC_OscConfig+0x6a>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000596:	f7ff fe6d 	bl	8000274 <HAL_GetTick>
 800059a:	1bc0      	subs	r0, r0, r7
 800059c:	2864      	cmp	r0, #100	; 0x64
 800059e:	d900      	bls.n	80005a2 <HAL_RCC_OscConfig+0x6a>
 80005a0:	e14e      	b.n	8000840 <HAL_RCC_OscConfig+0x308>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80005a2:	6833      	ldr	r3, [r6, #0]
 80005a4:	422b      	tst	r3, r5
 80005a6:	d0f6      	beq.n	8000596 <HAL_RCC_OscConfig+0x5e>
 80005a8:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80005aa:	079a      	lsls	r2, r3, #30
 80005ac:	d529      	bpl.n	8000602 <HAL_RCC_OscConfig+0xca>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 80005ae:	220c      	movs	r2, #12
 80005b0:	49ac      	ldr	r1, [pc, #688]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 80005b2:	6848      	ldr	r0, [r1, #4]
 80005b4:	4202      	tst	r2, r0
 80005b6:	d100      	bne.n	80005ba <HAL_RCC_OscConfig+0x82>
 80005b8:	e0e7      	b.n	800078a <HAL_RCC_OscConfig+0x252>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 80005ba:	6848      	ldr	r0, [r1, #4]
 80005bc:	4002      	ands	r2, r0
 80005be:	2a08      	cmp	r2, #8
 80005c0:	d100      	bne.n	80005c4 <HAL_RCC_OscConfig+0x8c>
 80005c2:	e0d9      	b.n	8000778 <HAL_RCC_OscConfig+0x240>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80005c4:	68e3      	ldr	r3, [r4, #12]
 80005c6:	2b00      	cmp	r3, #0
 80005c8:	d100      	bne.n	80005cc <HAL_RCC_OscConfig+0x94>
 80005ca:	e17b      	b.n	80008c4 <HAL_RCC_OscConfig+0x38c>
      {
       /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80005cc:	2201      	movs	r2, #1
 80005ce:	4fa5      	ldr	r7, [pc, #660]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80005d0:	2502      	movs	r5, #2
        __HAL_RCC_HSI_ENABLE();
 80005d2:	683b      	ldr	r3, [r7, #0]
 80005d4:	4313      	orrs	r3, r2
 80005d6:	603b      	str	r3, [r7, #0]
        tickstart = HAL_GetTick();
 80005d8:	f7ff fe4c 	bl	8000274 <HAL_GetTick>
 80005dc:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80005de:	e005      	b.n	80005ec <HAL_RCC_OscConfig+0xb4>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80005e0:	f7ff fe48 	bl	8000274 <HAL_GetTick>
 80005e4:	1b80      	subs	r0, r0, r6
 80005e6:	2802      	cmp	r0, #2
 80005e8:	d900      	bls.n	80005ec <HAL_RCC_OscConfig+0xb4>
 80005ea:	e129      	b.n	8000840 <HAL_RCC_OscConfig+0x308>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80005ec:	683b      	ldr	r3, [r7, #0]
 80005ee:	421d      	tst	r5, r3
 80005f0:	d0f6      	beq.n	80005e0 <HAL_RCC_OscConfig+0xa8>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80005f2:	21f8      	movs	r1, #248	; 0xf8
 80005f4:	683a      	ldr	r2, [r7, #0]
 80005f6:	6923      	ldr	r3, [r4, #16]
 80005f8:	438a      	bics	r2, r1
 80005fa:	00db      	lsls	r3, r3, #3
 80005fc:	4313      	orrs	r3, r2
 80005fe:	603b      	str	r3, [r7, #0]
 8000600:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000602:	071a      	lsls	r2, r3, #28
 8000604:	d42b      	bmi.n	800065e <HAL_RCC_OscConfig+0x126>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000606:	075a      	lsls	r2, r3, #29
 8000608:	d543      	bpl.n	8000692 <HAL_RCC_OscConfig+0x15a>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800060a:	2280      	movs	r2, #128	; 0x80
 800060c:	4b95      	ldr	r3, [pc, #596]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 800060e:	0552      	lsls	r2, r2, #21
 8000610:	69d9      	ldr	r1, [r3, #28]
    FlagStatus       pwrclkchanged = RESET;
 8000612:	2500      	movs	r5, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000614:	4211      	tst	r1, r2
 8000616:	d107      	bne.n	8000628 <HAL_RCC_OscConfig+0xf0>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8000618:	69d9      	ldr	r1, [r3, #28]
      pwrclkchanged = SET;
 800061a:	3501      	adds	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 800061c:	4311      	orrs	r1, r2
 800061e:	61d9      	str	r1, [r3, #28]
 8000620:	69db      	ldr	r3, [r3, #28]
 8000622:	401a      	ands	r2, r3
 8000624:	9201      	str	r2, [sp, #4]
 8000626:	9b01      	ldr	r3, [sp, #4]
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000628:	2680      	movs	r6, #128	; 0x80
 800062a:	4f91      	ldr	r7, [pc, #580]	; (8000870 <HAL_RCC_OscConfig+0x338>)
 800062c:	0076      	lsls	r6, r6, #1
 800062e:	683b      	ldr	r3, [r7, #0]
 8000630:	4233      	tst	r3, r6
 8000632:	d100      	bne.n	8000636 <HAL_RCC_OscConfig+0xfe>
 8000634:	e0d6      	b.n	80007e4 <HAL_RCC_OscConfig+0x2ac>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000636:	68a3      	ldr	r3, [r4, #8]
 8000638:	2b01      	cmp	r3, #1
 800063a:	d100      	bne.n	800063e <HAL_RCC_OscConfig+0x106>
 800063c:	e0e3      	b.n	8000806 <HAL_RCC_OscConfig+0x2ce>
 800063e:	2b00      	cmp	r3, #0
 8000640:	d100      	bne.n	8000644 <HAL_RCC_OscConfig+0x10c>
 8000642:	e125      	b.n	8000890 <HAL_RCC_OscConfig+0x358>
 8000644:	2b05      	cmp	r3, #5
 8000646:	d100      	bne.n	800064a <HAL_RCC_OscConfig+0x112>
 8000648:	e195      	b.n	8000976 <HAL_RCC_OscConfig+0x43e>
 800064a:	2101      	movs	r1, #1
 800064c:	4b85      	ldr	r3, [pc, #532]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 800064e:	6a1a      	ldr	r2, [r3, #32]
 8000650:	438a      	bics	r2, r1
 8000652:	621a      	str	r2, [r3, #32]
 8000654:	6a1a      	ldr	r2, [r3, #32]
 8000656:	3103      	adds	r1, #3
 8000658:	438a      	bics	r2, r1
 800065a:	621a      	str	r2, [r3, #32]
 800065c:	e0d7      	b.n	800080e <HAL_RCC_OscConfig+0x2d6>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800065e:	69e3      	ldr	r3, [r4, #28]
      __HAL_RCC_LSI_ENABLE();
 8000660:	4d80      	ldr	r5, [pc, #512]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000662:	2b00      	cmp	r3, #0
 8000664:	d100      	bne.n	8000668 <HAL_RCC_OscConfig+0x130>
 8000666:	e0a3      	b.n	80007b0 <HAL_RCC_OscConfig+0x278>
      __HAL_RCC_LSI_ENABLE();
 8000668:	2201      	movs	r2, #1
 800066a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800066c:	2602      	movs	r6, #2
      __HAL_RCC_LSI_ENABLE();
 800066e:	4313      	orrs	r3, r2
 8000670:	626b      	str	r3, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 8000672:	f7ff fdff 	bl	8000274 <HAL_GetTick>
 8000676:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000678:	e005      	b.n	8000686 <HAL_RCC_OscConfig+0x14e>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800067a:	f7ff fdfb 	bl	8000274 <HAL_GetTick>
 800067e:	1bc0      	subs	r0, r0, r7
 8000680:	2802      	cmp	r0, #2
 8000682:	d900      	bls.n	8000686 <HAL_RCC_OscConfig+0x14e>
 8000684:	e0dc      	b.n	8000840 <HAL_RCC_OscConfig+0x308>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000686:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8000688:	421e      	tst	r6, r3
 800068a:	d0f6      	beq.n	800067a <HAL_RCC_OscConfig+0x142>
 800068c:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800068e:	075a      	lsls	r2, r3, #29
 8000690:	d4bb      	bmi.n	800060a <HAL_RCC_OscConfig+0xd2>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*----------------------------- HSI14 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 8000692:	06da      	lsls	r2, r3, #27
 8000694:	d512      	bpl.n	80006bc <HAL_RCC_OscConfig+0x184>
    /* Check the parameters */
    assert_param(IS_RCC_HSI14(RCC_OscInitStruct->HSI14State));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSI14CalibrationValue));

    /* Check the HSI14 State */
    if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 8000696:	6962      	ldr	r2, [r4, #20]
 8000698:	2a01      	cmp	r2, #1
 800069a:	d100      	bne.n	800069e <HAL_RCC_OscConfig+0x166>
 800069c:	e175      	b.n	800098a <HAL_RCC_OscConfig+0x452>
      } 

      /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
    }
    else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 800069e:	3205      	adds	r2, #5
 80006a0:	d000      	beq.n	80006a4 <HAL_RCC_OscConfig+0x16c>
 80006a2:	e123      	b.n	80008ec <HAL_RCC_OscConfig+0x3b4>
    {
      /* Enable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_ENABLE();
 80006a4:	2004      	movs	r0, #4

      /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 80006a6:	25f8      	movs	r5, #248	; 0xf8
      __HAL_RCC_HSI14ADC_ENABLE();
 80006a8:	496e      	ldr	r1, [pc, #440]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 80006aa:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 80006ac:	4382      	bics	r2, r0
 80006ae:	634a      	str	r2, [r1, #52]	; 0x34
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 80006b0:	6b48      	ldr	r0, [r1, #52]	; 0x34
 80006b2:	69a2      	ldr	r2, [r4, #24]
 80006b4:	43a8      	bics	r0, r5
 80006b6:	00d2      	lsls	r2, r2, #3
 80006b8:	4302      	orrs	r2, r0
 80006ba:	634a      	str	r2, [r1, #52]	; 0x34
    }
  }

#if defined(RCC_HSI48_SUPPORT)
  /*----------------------------- HSI48 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80006bc:	069b      	lsls	r3, r3, #26
 80006be:	d522      	bpl.n	8000706 <HAL_RCC_OscConfig+0x1ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* When the HSI48 is used as system clock it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
 80006c0:	220c      	movs	r2, #12
 80006c2:	4968      	ldr	r1, [pc, #416]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 80006c4:	684b      	ldr	r3, [r1, #4]
 80006c6:	4013      	ands	r3, r2
 80006c8:	2b0c      	cmp	r3, #12
 80006ca:	d100      	bne.n	80006ce <HAL_RCC_OscConfig+0x196>
 80006cc:	e12d      	b.n	800092a <HAL_RCC_OscConfig+0x3f2>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI48)))
 80006ce:	684b      	ldr	r3, [r1, #4]
 80006d0:	401a      	ands	r2, r3
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
 80006d2:	2a08      	cmp	r2, #8
 80006d4:	d100      	bne.n	80006d8 <HAL_RCC_OscConfig+0x1a0>
 80006d6:	e121      	b.n	800091c <HAL_RCC_OscConfig+0x3e4>
      }
    }
    else
    {
      /* Check the HSI48 State */
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80006d8:	6a23      	ldr	r3, [r4, #32]
      {
        /* Enable the Internal High Speed oscillator (HSI48). */
        __HAL_RCC_HSI48_ENABLE();
 80006da:	4d62      	ldr	r5, [pc, #392]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
      if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80006dc:	2b00      	cmp	r3, #0
 80006de:	d100      	bne.n	80006e2 <HAL_RCC_OscConfig+0x1aa>
 80006e0:	e12e      	b.n	8000940 <HAL_RCC_OscConfig+0x408>
        __HAL_RCC_HSI48_ENABLE();
 80006e2:	2680      	movs	r6, #128	; 0x80
 80006e4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80006e6:	0276      	lsls	r6, r6, #9
 80006e8:	4333      	orrs	r3, r6
 80006ea:	636b      	str	r3, [r5, #52]	; 0x34

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80006ec:	f7ff fdc2 	bl	8000274 <HAL_GetTick>
 80006f0:	0007      	movs	r7, r0
      
        /* Wait till HSI48 is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 80006f2:	e005      	b.n	8000700 <HAL_RCC_OscConfig+0x1c8>
        {
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80006f4:	f7ff fdbe 	bl	8000274 <HAL_GetTick>
 80006f8:	1bc0      	subs	r0, r0, r7
 80006fa:	2802      	cmp	r0, #2
 80006fc:	d900      	bls.n	8000700 <HAL_RCC_OscConfig+0x1c8>
 80006fe:	e09f      	b.n	8000840 <HAL_RCC_OscConfig+0x308>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 8000700:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000702:	4233      	tst	r3, r6
 8000704:	d0f6      	beq.n	80006f4 <HAL_RCC_OscConfig+0x1bc>
#endif /* RCC_HSI48_SUPPORT */
       
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000706:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000708:	2b00      	cmp	r3, #0
 800070a:	d01b      	beq.n	8000744 <HAL_RCC_OscConfig+0x20c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800070c:	220c      	movs	r2, #12
 800070e:	4d55      	ldr	r5, [pc, #340]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 8000710:	6869      	ldr	r1, [r5, #4]
 8000712:	400a      	ands	r2, r1
 8000714:	2a08      	cmp	r2, #8
 8000716:	d02d      	beq.n	8000774 <HAL_RCC_OscConfig+0x23c>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8000718:	2b02      	cmp	r3, #2
 800071a:	d100      	bne.n	800071e <HAL_RCC_OscConfig+0x1e6>
 800071c:	e160      	b.n	80009e0 <HAL_RCC_OscConfig+0x4a8>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800071e:	682b      	ldr	r3, [r5, #0]
 8000720:	4a54      	ldr	r2, [pc, #336]	; (8000874 <HAL_RCC_OscConfig+0x33c>)
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000722:	2480      	movs	r4, #128	; 0x80
        __HAL_RCC_PLL_DISABLE();
 8000724:	4013      	ands	r3, r2
 8000726:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000728:	f7ff fda4 	bl	8000274 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800072c:	04a4      	lsls	r4, r4, #18
        tickstart = HAL_GetTick();
 800072e:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000730:	e005      	b.n	800073e <HAL_RCC_OscConfig+0x206>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000732:	f7ff fd9f 	bl	8000274 <HAL_GetTick>
 8000736:	1b80      	subs	r0, r0, r6
 8000738:	2802      	cmp	r0, #2
 800073a:	d900      	bls.n	800073e <HAL_RCC_OscConfig+0x206>
 800073c:	e080      	b.n	8000840 <HAL_RCC_OscConfig+0x308>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800073e:	682b      	ldr	r3, [r5, #0]
 8000740:	4223      	tst	r3, r4
 8000742:	d1f6      	bne.n	8000732 <HAL_RCC_OscConfig+0x1fa>
    {
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
 8000744:	2000      	movs	r0, #0
}
 8000746:	b003      	add	sp, #12
 8000748:	bc0c      	pop	{r2, r3}
 800074a:	4690      	mov	r8, r2
 800074c:	4699      	mov	r9, r3
 800074e:	bdf0      	pop	{r4, r5, r6, r7, pc}
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8000750:	21c0      	movs	r1, #192	; 0xc0
 8000752:	6842      	ldr	r2, [r0, #4]
 8000754:	0249      	lsls	r1, r1, #9
 8000756:	400a      	ands	r2, r1
 8000758:	2180      	movs	r1, #128	; 0x80
 800075a:	0249      	lsls	r1, r1, #9
 800075c:	428a      	cmp	r2, r1
 800075e:	d000      	beq.n	8000762 <HAL_RCC_OscConfig+0x22a>
 8000760:	e6ff      	b.n	8000562 <HAL_RCC_OscConfig+0x2a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000762:	4a40      	ldr	r2, [pc, #256]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 8000764:	6812      	ldr	r2, [r2, #0]
 8000766:	0392      	lsls	r2, r2, #14
 8000768:	d400      	bmi.n	800076c <HAL_RCC_OscConfig+0x234>
 800076a:	e71e      	b.n	80005aa <HAL_RCC_OscConfig+0x72>
 800076c:	6862      	ldr	r2, [r4, #4]
 800076e:	2a00      	cmp	r2, #0
 8000770:	d000      	beq.n	8000774 <HAL_RCC_OscConfig+0x23c>
 8000772:	e71a      	b.n	80005aa <HAL_RCC_OscConfig+0x72>
        return HAL_ERROR;
 8000774:	2001      	movs	r0, #1
 8000776:	e7e6      	b.n	8000746 <HAL_RCC_OscConfig+0x20e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8000778:	684a      	ldr	r2, [r1, #4]
 800077a:	21c0      	movs	r1, #192	; 0xc0
 800077c:	0249      	lsls	r1, r1, #9
 800077e:	400a      	ands	r2, r1
 8000780:	2180      	movs	r1, #128	; 0x80
 8000782:	0209      	lsls	r1, r1, #8
 8000784:	428a      	cmp	r2, r1
 8000786:	d000      	beq.n	800078a <HAL_RCC_OscConfig+0x252>
 8000788:	e71c      	b.n	80005c4 <HAL_RCC_OscConfig+0x8c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800078a:	4a36      	ldr	r2, [pc, #216]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 800078c:	6812      	ldr	r2, [r2, #0]
 800078e:	0792      	lsls	r2, r2, #30
 8000790:	d502      	bpl.n	8000798 <HAL_RCC_OscConfig+0x260>
 8000792:	68e2      	ldr	r2, [r4, #12]
 8000794:	2a01      	cmp	r2, #1
 8000796:	d1ed      	bne.n	8000774 <HAL_RCC_OscConfig+0x23c>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000798:	25f8      	movs	r5, #248	; 0xf8
 800079a:	4832      	ldr	r0, [pc, #200]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 800079c:	6922      	ldr	r2, [r4, #16]
 800079e:	6801      	ldr	r1, [r0, #0]
 80007a0:	00d2      	lsls	r2, r2, #3
 80007a2:	43a9      	bics	r1, r5
 80007a4:	430a      	orrs	r2, r1
 80007a6:	6002      	str	r2, [r0, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80007a8:	071a      	lsls	r2, r3, #28
 80007aa:	d400      	bmi.n	80007ae <HAL_RCC_OscConfig+0x276>
 80007ac:	e72b      	b.n	8000606 <HAL_RCC_OscConfig+0xce>
 80007ae:	e756      	b.n	800065e <HAL_RCC_OscConfig+0x126>
      __HAL_RCC_LSI_DISABLE();
 80007b0:	2201      	movs	r2, #1
 80007b2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80007b4:	2602      	movs	r6, #2
      __HAL_RCC_LSI_DISABLE();
 80007b6:	4393      	bics	r3, r2
 80007b8:	626b      	str	r3, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 80007ba:	f7ff fd5b 	bl	8000274 <HAL_GetTick>
 80007be:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80007c0:	e004      	b.n	80007cc <HAL_RCC_OscConfig+0x294>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80007c2:	f7ff fd57 	bl	8000274 <HAL_GetTick>
 80007c6:	1bc0      	subs	r0, r0, r7
 80007c8:	2802      	cmp	r0, #2
 80007ca:	d839      	bhi.n	8000840 <HAL_RCC_OscConfig+0x308>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80007cc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80007ce:	421e      	tst	r6, r3
 80007d0:	d1f7      	bne.n	80007c2 <HAL_RCC_OscConfig+0x28a>
 80007d2:	6823      	ldr	r3, [r4, #0]
 80007d4:	e75b      	b.n	800068e <HAL_RCC_OscConfig+0x156>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80007d6:	2380      	movs	r3, #128	; 0x80
 80007d8:	4a22      	ldr	r2, [pc, #136]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 80007da:	025b      	lsls	r3, r3, #9
 80007dc:	6811      	ldr	r1, [r2, #0]
 80007de:	430b      	orrs	r3, r1
 80007e0:	6013      	str	r3, [r2, #0]
 80007e2:	e6d1      	b.n	8000588 <HAL_RCC_OscConfig+0x50>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80007e4:	683b      	ldr	r3, [r7, #0]
 80007e6:	4333      	orrs	r3, r6
 80007e8:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 80007ea:	f7ff fd43 	bl	8000274 <HAL_GetTick>
 80007ee:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80007f0:	e005      	b.n	80007fe <HAL_RCC_OscConfig+0x2c6>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80007f2:	f7ff fd3f 	bl	8000274 <HAL_GetTick>
 80007f6:	4643      	mov	r3, r8
 80007f8:	1ac0      	subs	r0, r0, r3
 80007fa:	2864      	cmp	r0, #100	; 0x64
 80007fc:	d820      	bhi.n	8000840 <HAL_RCC_OscConfig+0x308>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80007fe:	683b      	ldr	r3, [r7, #0]
 8000800:	4233      	tst	r3, r6
 8000802:	d0f6      	beq.n	80007f2 <HAL_RCC_OscConfig+0x2ba>
 8000804:	e717      	b.n	8000636 <HAL_RCC_OscConfig+0xfe>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000806:	4917      	ldr	r1, [pc, #92]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 8000808:	6a0a      	ldr	r2, [r1, #32]
 800080a:	4313      	orrs	r3, r2
 800080c:	620b      	str	r3, [r1, #32]
      tickstart = HAL_GetTick();
 800080e:	f7ff fd31 	bl	8000274 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000812:	4b19      	ldr	r3, [pc, #100]	; (8000878 <HAL_RCC_OscConfig+0x340>)
      tickstart = HAL_GetTick();
 8000814:	4681      	mov	r9, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000816:	4f13      	ldr	r7, [pc, #76]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 8000818:	2602      	movs	r6, #2
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800081a:	4698      	mov	r8, r3
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800081c:	e005      	b.n	800082a <HAL_RCC_OscConfig+0x2f2>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800081e:	f7ff fd29 	bl	8000274 <HAL_GetTick>
 8000822:	464b      	mov	r3, r9
 8000824:	1ac0      	subs	r0, r0, r3
 8000826:	4540      	cmp	r0, r8
 8000828:	d80a      	bhi.n	8000840 <HAL_RCC_OscConfig+0x308>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800082a:	6a3b      	ldr	r3, [r7, #32]
 800082c:	421e      	tst	r6, r3
 800082e:	d0f6      	beq.n	800081e <HAL_RCC_OscConfig+0x2e6>
    if(pwrclkchanged == SET)
 8000830:	2d01      	cmp	r5, #1
 8000832:	d100      	bne.n	8000836 <HAL_RCC_OscConfig+0x2fe>
 8000834:	e098      	b.n	8000968 <HAL_RCC_OscConfig+0x430>
 8000836:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 8000838:	06da      	lsls	r2, r3, #27
 800083a:	d400      	bmi.n	800083e <HAL_RCC_OscConfig+0x306>
 800083c:	e73e      	b.n	80006bc <HAL_RCC_OscConfig+0x184>
 800083e:	e72a      	b.n	8000696 <HAL_RCC_OscConfig+0x15e>
            return HAL_TIMEOUT;
 8000840:	2003      	movs	r0, #3
 8000842:	e780      	b.n	8000746 <HAL_RCC_OscConfig+0x20e>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000844:	4d07      	ldr	r5, [pc, #28]	; (8000864 <HAL_RCC_OscConfig+0x32c>)
 8000846:	4a08      	ldr	r2, [pc, #32]	; (8000868 <HAL_RCC_OscConfig+0x330>)
 8000848:	682b      	ldr	r3, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800084a:	2680      	movs	r6, #128	; 0x80
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800084c:	4013      	ands	r3, r2
 800084e:	602b      	str	r3, [r5, #0]
 8000850:	682b      	ldr	r3, [r5, #0]
 8000852:	4a06      	ldr	r2, [pc, #24]	; (800086c <HAL_RCC_OscConfig+0x334>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000854:	02b6      	lsls	r6, r6, #10
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000856:	4013      	ands	r3, r2
 8000858:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800085a:	f7ff fd0b 	bl	8000274 <HAL_GetTick>
 800085e:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000860:	e011      	b.n	8000886 <HAL_RCC_OscConfig+0x34e>
 8000862:	46c0      	nop			; (mov r8, r8)
 8000864:	40021000 	.word	0x40021000
 8000868:	fffeffff 	.word	0xfffeffff
 800086c:	fffbffff 	.word	0xfffbffff
 8000870:	40007000 	.word	0x40007000
 8000874:	feffffff 	.word	0xfeffffff
 8000878:	00001388 	.word	0x00001388
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800087c:	f7ff fcfa 	bl	8000274 <HAL_GetTick>
 8000880:	1bc0      	subs	r0, r0, r7
 8000882:	2864      	cmp	r0, #100	; 0x64
 8000884:	d8dc      	bhi.n	8000840 <HAL_RCC_OscConfig+0x308>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000886:	682b      	ldr	r3, [r5, #0]
 8000888:	4233      	tst	r3, r6
 800088a:	d1f7      	bne.n	800087c <HAL_RCC_OscConfig+0x344>
 800088c:	6823      	ldr	r3, [r4, #0]
 800088e:	e68c      	b.n	80005aa <HAL_RCC_OscConfig+0x72>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000890:	2201      	movs	r2, #1
 8000892:	4e6f      	ldr	r6, [pc, #444]	; (8000a50 <HAL_RCC_OscConfig+0x518>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000894:	2702      	movs	r7, #2
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000896:	6a33      	ldr	r3, [r6, #32]
 8000898:	4393      	bics	r3, r2
 800089a:	6233      	str	r3, [r6, #32]
 800089c:	6a33      	ldr	r3, [r6, #32]
 800089e:	3203      	adds	r2, #3
 80008a0:	4393      	bics	r3, r2
 80008a2:	6233      	str	r3, [r6, #32]
      tickstart = HAL_GetTick();
 80008a4:	f7ff fce6 	bl	8000274 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80008a8:	4b6a      	ldr	r3, [pc, #424]	; (8000a54 <HAL_RCC_OscConfig+0x51c>)
      tickstart = HAL_GetTick();
 80008aa:	4681      	mov	r9, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80008ac:	4698      	mov	r8, r3
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80008ae:	e005      	b.n	80008bc <HAL_RCC_OscConfig+0x384>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80008b0:	f7ff fce0 	bl	8000274 <HAL_GetTick>
 80008b4:	464b      	mov	r3, r9
 80008b6:	1ac0      	subs	r0, r0, r3
 80008b8:	4540      	cmp	r0, r8
 80008ba:	d8c1      	bhi.n	8000840 <HAL_RCC_OscConfig+0x308>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80008bc:	6a33      	ldr	r3, [r6, #32]
 80008be:	421f      	tst	r7, r3
 80008c0:	d1f6      	bne.n	80008b0 <HAL_RCC_OscConfig+0x378>
 80008c2:	e7b5      	b.n	8000830 <HAL_RCC_OscConfig+0x2f8>
        __HAL_RCC_HSI_DISABLE();
 80008c4:	2201      	movs	r2, #1
 80008c6:	4d62      	ldr	r5, [pc, #392]	; (8000a50 <HAL_RCC_OscConfig+0x518>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80008c8:	2602      	movs	r6, #2
        __HAL_RCC_HSI_DISABLE();
 80008ca:	682b      	ldr	r3, [r5, #0]
 80008cc:	4393      	bics	r3, r2
 80008ce:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80008d0:	f7ff fcd0 	bl	8000274 <HAL_GetTick>
 80008d4:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80008d6:	e004      	b.n	80008e2 <HAL_RCC_OscConfig+0x3aa>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80008d8:	f7ff fccc 	bl	8000274 <HAL_GetTick>
 80008dc:	1bc0      	subs	r0, r0, r7
 80008de:	2802      	cmp	r0, #2
 80008e0:	d8ae      	bhi.n	8000840 <HAL_RCC_OscConfig+0x308>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80008e2:	682b      	ldr	r3, [r5, #0]
 80008e4:	421e      	tst	r6, r3
 80008e6:	d1f7      	bne.n	80008d8 <HAL_RCC_OscConfig+0x3a0>
 80008e8:	6823      	ldr	r3, [r4, #0]
 80008ea:	e68a      	b.n	8000602 <HAL_RCC_OscConfig+0xca>
      __HAL_RCC_HSI14ADC_DISABLE();
 80008ec:	2204      	movs	r2, #4
 80008ee:	4d58      	ldr	r5, [pc, #352]	; (8000a50 <HAL_RCC_OscConfig+0x518>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 80008f0:	2602      	movs	r6, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 80008f2:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80008f4:	4313      	orrs	r3, r2
 80008f6:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_DISABLE();
 80008f8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80008fa:	3a03      	subs	r2, #3
 80008fc:	4393      	bics	r3, r2
 80008fe:	636b      	str	r3, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 8000900:	f7ff fcb8 	bl	8000274 <HAL_GetTick>
 8000904:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 8000906:	e004      	b.n	8000912 <HAL_RCC_OscConfig+0x3da>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 8000908:	f7ff fcb4 	bl	8000274 <HAL_GetTick>
 800090c:	1bc0      	subs	r0, r0, r7
 800090e:	2802      	cmp	r0, #2
 8000910:	d896      	bhi.n	8000840 <HAL_RCC_OscConfig+0x308>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 8000912:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000914:	421e      	tst	r6, r3
 8000916:	d1f7      	bne.n	8000908 <HAL_RCC_OscConfig+0x3d0>
 8000918:	6823      	ldr	r3, [r4, #0]
 800091a:	e6cf      	b.n	80006bc <HAL_RCC_OscConfig+0x184>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI48)))
 800091c:	22c0      	movs	r2, #192	; 0xc0
 800091e:	684b      	ldr	r3, [r1, #4]
 8000920:	0252      	lsls	r2, r2, #9
 8000922:	4013      	ands	r3, r2
 8000924:	4293      	cmp	r3, r2
 8000926:	d000      	beq.n	800092a <HAL_RCC_OscConfig+0x3f2>
 8000928:	e6d6      	b.n	80006d8 <HAL_RCC_OscConfig+0x1a0>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET) && (RCC_OscInitStruct->HSI48State != RCC_HSI48_ON))
 800092a:	4b49      	ldr	r3, [pc, #292]	; (8000a50 <HAL_RCC_OscConfig+0x518>)
 800092c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800092e:	03db      	lsls	r3, r3, #15
 8000930:	d400      	bmi.n	8000934 <HAL_RCC_OscConfig+0x3fc>
 8000932:	e6e8      	b.n	8000706 <HAL_RCC_OscConfig+0x1ce>
 8000934:	6a23      	ldr	r3, [r4, #32]
 8000936:	2b01      	cmp	r3, #1
 8000938:	d100      	bne.n	800093c <HAL_RCC_OscConfig+0x404>
 800093a:	e6e4      	b.n	8000706 <HAL_RCC_OscConfig+0x1ce>
        return HAL_ERROR;
 800093c:	2001      	movs	r0, #1
 800093e:	e702      	b.n	8000746 <HAL_RCC_OscConfig+0x20e>
        __HAL_RCC_HSI48_DISABLE();
 8000940:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000942:	4a45      	ldr	r2, [pc, #276]	; (8000a58 <HAL_RCC_OscConfig+0x520>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 8000944:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_HSI48_DISABLE();
 8000946:	4013      	ands	r3, r2
 8000948:	636b      	str	r3, [r5, #52]	; 0x34
        tickstart = HAL_GetTick();
 800094a:	f7ff fc93 	bl	8000274 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 800094e:	0276      	lsls	r6, r6, #9
        tickstart = HAL_GetTick();
 8000950:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 8000952:	e005      	b.n	8000960 <HAL_RCC_OscConfig+0x428>
          if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8000954:	f7ff fc8e 	bl	8000274 <HAL_GetTick>
 8000958:	1bc0      	subs	r0, r0, r7
 800095a:	2802      	cmp	r0, #2
 800095c:	d900      	bls.n	8000960 <HAL_RCC_OscConfig+0x428>
 800095e:	e76f      	b.n	8000840 <HAL_RCC_OscConfig+0x308>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 8000960:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000962:	4233      	tst	r3, r6
 8000964:	d1f6      	bne.n	8000954 <HAL_RCC_OscConfig+0x41c>
 8000966:	e6ce      	b.n	8000706 <HAL_RCC_OscConfig+0x1ce>
      __HAL_RCC_PWR_CLK_DISABLE();
 8000968:	4a39      	ldr	r2, [pc, #228]	; (8000a50 <HAL_RCC_OscConfig+0x518>)
 800096a:	493c      	ldr	r1, [pc, #240]	; (8000a5c <HAL_RCC_OscConfig+0x524>)
 800096c:	69d3      	ldr	r3, [r2, #28]
 800096e:	400b      	ands	r3, r1
 8000970:	61d3      	str	r3, [r2, #28]
 8000972:	6823      	ldr	r3, [r4, #0]
 8000974:	e760      	b.n	8000838 <HAL_RCC_OscConfig+0x300>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000976:	2104      	movs	r1, #4
 8000978:	4b35      	ldr	r3, [pc, #212]	; (8000a50 <HAL_RCC_OscConfig+0x518>)
 800097a:	6a1a      	ldr	r2, [r3, #32]
 800097c:	430a      	orrs	r2, r1
 800097e:	621a      	str	r2, [r3, #32]
 8000980:	6a1a      	ldr	r2, [r3, #32]
 8000982:	3903      	subs	r1, #3
 8000984:	430a      	orrs	r2, r1
 8000986:	621a      	str	r2, [r3, #32]
 8000988:	e741      	b.n	800080e <HAL_RCC_OscConfig+0x2d6>
      __HAL_RCC_HSI14ADC_DISABLE();
 800098a:	2104      	movs	r1, #4
 800098c:	4d30      	ldr	r5, [pc, #192]	; (8000a50 <HAL_RCC_OscConfig+0x518>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 800098e:	2602      	movs	r6, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 8000990:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000992:	430b      	orrs	r3, r1
 8000994:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_ENABLE();
 8000996:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000998:	431a      	orrs	r2, r3
 800099a:	636a      	str	r2, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 800099c:	f7ff fc6a 	bl	8000274 <HAL_GetTick>
 80009a0:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 80009a2:	e005      	b.n	80009b0 <HAL_RCC_OscConfig+0x478>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 80009a4:	f7ff fc66 	bl	8000274 <HAL_GetTick>
 80009a8:	1bc0      	subs	r0, r0, r7
 80009aa:	2802      	cmp	r0, #2
 80009ac:	d900      	bls.n	80009b0 <HAL_RCC_OscConfig+0x478>
 80009ae:	e747      	b.n	8000840 <HAL_RCC_OscConfig+0x308>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 80009b0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80009b2:	421e      	tst	r6, r3
 80009b4:	d0f6      	beq.n	80009a4 <HAL_RCC_OscConfig+0x46c>
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 80009b6:	21f8      	movs	r1, #248	; 0xf8
 80009b8:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80009ba:	69a3      	ldr	r3, [r4, #24]
 80009bc:	438a      	bics	r2, r1
 80009be:	00db      	lsls	r3, r3, #3
 80009c0:	4313      	orrs	r3, r2
 80009c2:	636b      	str	r3, [r5, #52]	; 0x34
 80009c4:	6823      	ldr	r3, [r4, #0]
 80009c6:	e679      	b.n	80006bc <HAL_RCC_OscConfig+0x184>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80009c8:	2280      	movs	r2, #128	; 0x80
 80009ca:	4b21      	ldr	r3, [pc, #132]	; (8000a50 <HAL_RCC_OscConfig+0x518>)
 80009cc:	02d2      	lsls	r2, r2, #11
 80009ce:	6819      	ldr	r1, [r3, #0]
 80009d0:	430a      	orrs	r2, r1
 80009d2:	601a      	str	r2, [r3, #0]
 80009d4:	2280      	movs	r2, #128	; 0x80
 80009d6:	6819      	ldr	r1, [r3, #0]
 80009d8:	0252      	lsls	r2, r2, #9
 80009da:	430a      	orrs	r2, r1
 80009dc:	601a      	str	r2, [r3, #0]
 80009de:	e5d3      	b.n	8000588 <HAL_RCC_OscConfig+0x50>
        __HAL_RCC_PLL_DISABLE();
 80009e0:	682b      	ldr	r3, [r5, #0]
 80009e2:	4a1f      	ldr	r2, [pc, #124]	; (8000a60 <HAL_RCC_OscConfig+0x528>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80009e4:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_PLL_DISABLE();
 80009e6:	4013      	ands	r3, r2
 80009e8:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80009ea:	f7ff fc43 	bl	8000274 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80009ee:	04b6      	lsls	r6, r6, #18
        tickstart = HAL_GetTick();
 80009f0:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80009f2:	e005      	b.n	8000a00 <HAL_RCC_OscConfig+0x4c8>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80009f4:	f7ff fc3e 	bl	8000274 <HAL_GetTick>
 80009f8:	1bc0      	subs	r0, r0, r7
 80009fa:	2802      	cmp	r0, #2
 80009fc:	d900      	bls.n	8000a00 <HAL_RCC_OscConfig+0x4c8>
 80009fe:	e71f      	b.n	8000840 <HAL_RCC_OscConfig+0x308>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000a00:	682b      	ldr	r3, [r5, #0]
 8000a02:	4233      	tst	r3, r6
 8000a04:	d1f6      	bne.n	80009f4 <HAL_RCC_OscConfig+0x4bc>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000a06:	220f      	movs	r2, #15
 8000a08:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8000a0a:	4393      	bics	r3, r2
 8000a0c:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8000a0e:	4313      	orrs	r3, r2
 8000a10:	62eb      	str	r3, [r5, #44]	; 0x2c
 8000a12:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000a14:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000a16:	686a      	ldr	r2, [r5, #4]
 8000a18:	430b      	orrs	r3, r1
 8000a1a:	4912      	ldr	r1, [pc, #72]	; (8000a64 <HAL_RCC_OscConfig+0x52c>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000a1c:	2480      	movs	r4, #128	; 0x80
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000a1e:	400a      	ands	r2, r1
 8000a20:	4313      	orrs	r3, r2
 8000a22:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8000a24:	2380      	movs	r3, #128	; 0x80
 8000a26:	682a      	ldr	r2, [r5, #0]
 8000a28:	045b      	lsls	r3, r3, #17
 8000a2a:	4313      	orrs	r3, r2
 8000a2c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000a2e:	f7ff fc21 	bl	8000274 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000a32:	4d07      	ldr	r5, [pc, #28]	; (8000a50 <HAL_RCC_OscConfig+0x518>)
        tickstart = HAL_GetTick();
 8000a34:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000a36:	04a4      	lsls	r4, r4, #18
 8000a38:	e005      	b.n	8000a46 <HAL_RCC_OscConfig+0x50e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000a3a:	f7ff fc1b 	bl	8000274 <HAL_GetTick>
 8000a3e:	1b80      	subs	r0, r0, r6
 8000a40:	2802      	cmp	r0, #2
 8000a42:	d900      	bls.n	8000a46 <HAL_RCC_OscConfig+0x50e>
 8000a44:	e6fc      	b.n	8000840 <HAL_RCC_OscConfig+0x308>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000a46:	682b      	ldr	r3, [r5, #0]
 8000a48:	4223      	tst	r3, r4
 8000a4a:	d0f6      	beq.n	8000a3a <HAL_RCC_OscConfig+0x502>
 8000a4c:	e67a      	b.n	8000744 <HAL_RCC_OscConfig+0x20c>
 8000a4e:	46c0      	nop			; (mov r8, r8)
 8000a50:	40021000 	.word	0x40021000
 8000a54:	00001388 	.word	0x00001388
 8000a58:	fffeffff 	.word	0xfffeffff
 8000a5c:	efffffff 	.word	0xefffffff
 8000a60:	feffffff 	.word	0xfeffffff
 8000a64:	ffc27fff 	.word	0xffc27fff

08000a68 <HAL_RCC_ClockConfig>:
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8000a68:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a6a:	46ce      	mov	lr, r9
 8000a6c:	4647      	mov	r7, r8
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000a6e:	2301      	movs	r3, #1
{
 8000a70:	b580      	push	{r7, lr}
 8000a72:	000c      	movs	r4, r1
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000a74:	4974      	ldr	r1, [pc, #464]	; (8000c48 <HAL_RCC_ClockConfig+0x1e0>)
{
 8000a76:	b089      	sub	sp, #36	; 0x24
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000a78:	680a      	ldr	r2, [r1, #0]
{
 8000a7a:	0005      	movs	r5, r0
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000a7c:	401a      	ands	r2, r3
 8000a7e:	42a2      	cmp	r2, r4
 8000a80:	d20d      	bcs.n	8000a9e <HAL_RCC_ClockConfig+0x36>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000a82:	680a      	ldr	r2, [r1, #0]
 8000a84:	439a      	bics	r2, r3
 8000a86:	4322      	orrs	r2, r4
 8000a88:	600a      	str	r2, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000a8a:	680a      	ldr	r2, [r1, #0]
 8000a8c:	4013      	ands	r3, r2
 8000a8e:	42a3      	cmp	r3, r4
 8000a90:	d005      	beq.n	8000a9e <HAL_RCC_ClockConfig+0x36>
    {
      return HAL_ERROR;
 8000a92:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
  
  return HAL_OK;
}
 8000a94:	b009      	add	sp, #36	; 0x24
 8000a96:	bc0c      	pop	{r2, r3}
 8000a98:	4690      	mov	r8, r2
 8000a9a:	4699      	mov	r9, r3
 8000a9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000a9e:	682b      	ldr	r3, [r5, #0]
 8000aa0:	079a      	lsls	r2, r3, #30
 8000aa2:	d506      	bpl.n	8000ab2 <HAL_RCC_ClockConfig+0x4a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000aa4:	20f0      	movs	r0, #240	; 0xf0
 8000aa6:	4969      	ldr	r1, [pc, #420]	; (8000c4c <HAL_RCC_ClockConfig+0x1e4>)
 8000aa8:	684a      	ldr	r2, [r1, #4]
 8000aaa:	4382      	bics	r2, r0
 8000aac:	68a8      	ldr	r0, [r5, #8]
 8000aae:	4302      	orrs	r2, r0
 8000ab0:	604a      	str	r2, [r1, #4]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000ab2:	07db      	lsls	r3, r3, #31
 8000ab4:	d52b      	bpl.n	8000b0e <HAL_RCC_ClockConfig+0xa6>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000ab6:	686b      	ldr	r3, [r5, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000ab8:	4a64      	ldr	r2, [pc, #400]	; (8000c4c <HAL_RCC_ClockConfig+0x1e4>)
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000aba:	2b01      	cmp	r3, #1
 8000abc:	d06e      	beq.n	8000b9c <HAL_RCC_ClockConfig+0x134>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000abe:	2b02      	cmp	r3, #2
 8000ac0:	d068      	beq.n	8000b94 <HAL_RCC_ClockConfig+0x12c>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 8000ac2:	2b03      	cmp	r3, #3
 8000ac4:	d100      	bne.n	8000ac8 <HAL_RCC_ClockConfig+0x60>
 8000ac6:	e094      	b.n	8000bf2 <HAL_RCC_ClockConfig+0x18a>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000ac8:	6812      	ldr	r2, [r2, #0]
 8000aca:	0792      	lsls	r2, r2, #30
 8000acc:	d5e1      	bpl.n	8000a92 <HAL_RCC_ClockConfig+0x2a>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000ace:	2103      	movs	r1, #3
 8000ad0:	4e5e      	ldr	r6, [pc, #376]	; (8000c4c <HAL_RCC_ClockConfig+0x1e4>)
 8000ad2:	6872      	ldr	r2, [r6, #4]
 8000ad4:	438a      	bics	r2, r1
 8000ad6:	4313      	orrs	r3, r2
 8000ad8:	6073      	str	r3, [r6, #4]
    tickstart = HAL_GetTick();
 8000ada:	f7ff fbcb 	bl	8000274 <HAL_GetTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000ade:	686b      	ldr	r3, [r5, #4]
    tickstart = HAL_GetTick();
 8000ae0:	0007      	movs	r7, r0
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000ae2:	2b01      	cmp	r3, #1
 8000ae4:	d075      	beq.n	8000bd2 <HAL_RCC_ClockConfig+0x16a>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000ae6:	2b02      	cmp	r3, #2
 8000ae8:	d100      	bne.n	8000aec <HAL_RCC_ClockConfig+0x84>
 8000aea:	e087      	b.n	8000bfc <HAL_RCC_ClockConfig+0x194>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 8000aec:	2b03      	cmp	r3, #3
 8000aee:	d100      	bne.n	8000af2 <HAL_RCC_ClockConfig+0x8a>
 8000af0:	e094      	b.n	8000c1c <HAL_RCC_ClockConfig+0x1b4>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8000af2:	230c      	movs	r3, #12
 8000af4:	4698      	mov	r8, r3
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000af6:	4b56      	ldr	r3, [pc, #344]	; (8000c50 <HAL_RCC_ClockConfig+0x1e8>)
 8000af8:	4699      	mov	r9, r3
 8000afa:	e004      	b.n	8000b06 <HAL_RCC_ClockConfig+0x9e>
 8000afc:	f7ff fbba 	bl	8000274 <HAL_GetTick>
 8000b00:	1bc0      	subs	r0, r0, r7
 8000b02:	4548      	cmp	r0, r9
 8000b04:	d863      	bhi.n	8000bce <HAL_RCC_ClockConfig+0x166>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8000b06:	4642      	mov	r2, r8
 8000b08:	6873      	ldr	r3, [r6, #4]
 8000b0a:	421a      	tst	r2, r3
 8000b0c:	d1f6      	bne.n	8000afc <HAL_RCC_ClockConfig+0x94>
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8000b0e:	2101      	movs	r1, #1
 8000b10:	4a4d      	ldr	r2, [pc, #308]	; (8000c48 <HAL_RCC_ClockConfig+0x1e0>)
 8000b12:	6813      	ldr	r3, [r2, #0]
 8000b14:	400b      	ands	r3, r1
 8000b16:	42a3      	cmp	r3, r4
 8000b18:	d905      	bls.n	8000b26 <HAL_RCC_ClockConfig+0xbe>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000b1a:	6813      	ldr	r3, [r2, #0]
 8000b1c:	438b      	bics	r3, r1
 8000b1e:	6013      	str	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000b20:	6813      	ldr	r3, [r2, #0]
 8000b22:	4219      	tst	r1, r3
 8000b24:	d1b5      	bne.n	8000a92 <HAL_RCC_ClockConfig+0x2a>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000b26:	682b      	ldr	r3, [r5, #0]
 8000b28:	075b      	lsls	r3, r3, #29
 8000b2a:	d42b      	bmi.n	8000b84 <HAL_RCC_ClockConfig+0x11c>
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000b2c:	4669      	mov	r1, sp
 8000b2e:	4b49      	ldr	r3, [pc, #292]	; (8000c54 <HAL_RCC_ClockConfig+0x1ec>)
 8000b30:	000a      	movs	r2, r1
 8000b32:	0018      	movs	r0, r3
 8000b34:	c870      	ldmia	r0!, {r4, r5, r6}
 8000b36:	c270      	stmia	r2!, {r4, r5, r6}
 8000b38:	6800      	ldr	r0, [r0, #0]
                                         10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000b3a:	3310      	adds	r3, #16
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000b3c:	6010      	str	r0, [r2, #0]
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000b3e:	aa04      	add	r2, sp, #16
 8000b40:	0010      	movs	r0, r2
 8000b42:	cb70      	ldmia	r3!, {r4, r5, r6}
 8000b44:	c070      	stmia	r0!, {r4, r5, r6}
 8000b46:	681b      	ldr	r3, [r3, #0]
                                           9U,10U, 11U, 12U, 13U, 14U, 15U, 16U};

  uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
 8000b48:	4d40      	ldr	r5, [pc, #256]	; (8000c4c <HAL_RCC_ClockConfig+0x1e4>)
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000b4a:	6003      	str	r3, [r0, #0]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8000b4c:	200c      	movs	r0, #12
  tmpreg = RCC->CFGR;
 8000b4e:	686b      	ldr	r3, [r5, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8000b50:	4018      	ands	r0, r3
 8000b52:	2808      	cmp	r0, #8
 8000b54:	d026      	beq.n	8000ba4 <HAL_RCC_ClockConfig+0x13c>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 8000b56:	380c      	subs	r0, #12
 8000b58:	4243      	negs	r3, r0
 8000b5a:	4158      	adcs	r0, r3
 8000b5c:	4b3e      	ldr	r3, [pc, #248]	; (8000c58 <HAL_RCC_ClockConfig+0x1f0>)
 8000b5e:	4240      	negs	r0, r0
 8000b60:	4018      	ands	r0, r3
 8000b62:	4b3e      	ldr	r3, [pc, #248]	; (8000c5c <HAL_RCC_ClockConfig+0x1f4>)
 8000b64:	469c      	mov	ip, r3
 8000b66:	4460      	add	r0, ip
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 8000b68:	4b38      	ldr	r3, [pc, #224]	; (8000c4c <HAL_RCC_ClockConfig+0x1e4>)
 8000b6a:	4a3d      	ldr	r2, [pc, #244]	; (8000c60 <HAL_RCC_ClockConfig+0x1f8>)
 8000b6c:	685b      	ldr	r3, [r3, #4]
 8000b6e:	061b      	lsls	r3, r3, #24
 8000b70:	0f1b      	lsrs	r3, r3, #28
 8000b72:	5cd3      	ldrb	r3, [r2, r3]
 8000b74:	40d8      	lsrs	r0, r3
 8000b76:	4b3b      	ldr	r3, [pc, #236]	; (8000c64 <HAL_RCC_ClockConfig+0x1fc>)
 8000b78:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8000b7a:	2000      	movs	r0, #0
 8000b7c:	f7ff fb50 	bl	8000220 <HAL_InitTick>
  return HAL_OK;
 8000b80:	2000      	movs	r0, #0
 8000b82:	e787      	b.n	8000a94 <HAL_RCC_ClockConfig+0x2c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 8000b84:	4a31      	ldr	r2, [pc, #196]	; (8000c4c <HAL_RCC_ClockConfig+0x1e4>)
 8000b86:	4938      	ldr	r1, [pc, #224]	; (8000c68 <HAL_RCC_ClockConfig+0x200>)
 8000b88:	6853      	ldr	r3, [r2, #4]
 8000b8a:	400b      	ands	r3, r1
 8000b8c:	68e9      	ldr	r1, [r5, #12]
 8000b8e:	430b      	orrs	r3, r1
 8000b90:	6053      	str	r3, [r2, #4]
 8000b92:	e7cb      	b.n	8000b2c <HAL_RCC_ClockConfig+0xc4>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000b94:	6812      	ldr	r2, [r2, #0]
 8000b96:	0192      	lsls	r2, r2, #6
 8000b98:	d499      	bmi.n	8000ace <HAL_RCC_ClockConfig+0x66>
 8000b9a:	e77a      	b.n	8000a92 <HAL_RCC_ClockConfig+0x2a>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000b9c:	6812      	ldr	r2, [r2, #0]
 8000b9e:	0392      	lsls	r2, r2, #14
 8000ba0:	d495      	bmi.n	8000ace <HAL_RCC_ClockConfig+0x66>
 8000ba2:	e776      	b.n	8000a92 <HAL_RCC_ClockConfig+0x2a>
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8000ba4:	200f      	movs	r0, #15
 8000ba6:	0c9c      	lsrs	r4, r3, #18
 8000ba8:	4004      	ands	r4, r0
 8000baa:	5d0c      	ldrb	r4, [r1, r4]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8000bac:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8000bae:	4008      	ands	r0, r1
 8000bb0:	5c11      	ldrb	r1, [r2, r0]
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8000bb2:	22c0      	movs	r2, #192	; 0xc0
 8000bb4:	2080      	movs	r0, #128	; 0x80
 8000bb6:	0252      	lsls	r2, r2, #9
 8000bb8:	4013      	ands	r3, r2
 8000bba:	0240      	lsls	r0, r0, #9
 8000bbc:	4283      	cmp	r3, r0
 8000bbe:	d001      	beq.n	8000bc4 <HAL_RCC_ClockConfig+0x15c>
      {
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV * PLLMUL */
        pllclk = (HSE_VALUE / prediv) * pllmul;
      }
#if defined(RCC_CFGR_PLLSRC_HSI48_PREDIV)
      else if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSI48)
 8000bc0:	4293      	cmp	r3, r2
 8000bc2:	d03b      	beq.n	8000c3c <HAL_RCC_ClockConfig+0x1d4>
#endif /* RCC_CFGR_PLLSRC_HSI48_PREDIV */
      else
      {
#if  (defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6) || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC))
        /* HSI used as PLL clock source : PLLCLK = HSI/PREDIV * PLLMUL */
        pllclk = (HSI_VALUE / prediv) * pllmul;
 8000bc4:	4825      	ldr	r0, [pc, #148]	; (8000c5c <HAL_RCC_ClockConfig+0x1f4>)
 8000bc6:	f7ff fa9f 	bl	8000108 <__udivsi3>
 8000bca:	4360      	muls	r0, r4
 8000bcc:	e7cc      	b.n	8000b68 <HAL_RCC_ClockConfig+0x100>
          return HAL_TIMEOUT;
 8000bce:	2003      	movs	r0, #3
 8000bd0:	e760      	b.n	8000a94 <HAL_RCC_ClockConfig+0x2c>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8000bd2:	330b      	adds	r3, #11
 8000bd4:	4698      	mov	r8, r3
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000bd6:	4b1e      	ldr	r3, [pc, #120]	; (8000c50 <HAL_RCC_ClockConfig+0x1e8>)
 8000bd8:	4699      	mov	r9, r3
 8000bda:	e004      	b.n	8000be6 <HAL_RCC_ClockConfig+0x17e>
 8000bdc:	f7ff fb4a 	bl	8000274 <HAL_GetTick>
 8000be0:	1bc0      	subs	r0, r0, r7
 8000be2:	4548      	cmp	r0, r9
 8000be4:	d8f3      	bhi.n	8000bce <HAL_RCC_ClockConfig+0x166>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8000be6:	4642      	mov	r2, r8
 8000be8:	6873      	ldr	r3, [r6, #4]
 8000bea:	4013      	ands	r3, r2
 8000bec:	2b04      	cmp	r3, #4
 8000bee:	d1f5      	bne.n	8000bdc <HAL_RCC_ClockConfig+0x174>
 8000bf0:	e78d      	b.n	8000b0e <HAL_RCC_ClockConfig+0xa6>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 8000bf2:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8000bf4:	03d2      	lsls	r2, r2, #15
 8000bf6:	d500      	bpl.n	8000bfa <HAL_RCC_ClockConfig+0x192>
 8000bf8:	e769      	b.n	8000ace <HAL_RCC_ClockConfig+0x66>
 8000bfa:	e74a      	b.n	8000a92 <HAL_RCC_ClockConfig+0x2a>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000bfc:	330a      	adds	r3, #10
 8000bfe:	4698      	mov	r8, r3
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000c00:	4b13      	ldr	r3, [pc, #76]	; (8000c50 <HAL_RCC_ClockConfig+0x1e8>)
 8000c02:	4699      	mov	r9, r3
 8000c04:	e004      	b.n	8000c10 <HAL_RCC_ClockConfig+0x1a8>
 8000c06:	f7ff fb35 	bl	8000274 <HAL_GetTick>
 8000c0a:	1bc0      	subs	r0, r0, r7
 8000c0c:	4548      	cmp	r0, r9
 8000c0e:	d8de      	bhi.n	8000bce <HAL_RCC_ClockConfig+0x166>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000c10:	4642      	mov	r2, r8
 8000c12:	6873      	ldr	r3, [r6, #4]
 8000c14:	4013      	ands	r3, r2
 8000c16:	2b08      	cmp	r3, #8
 8000c18:	d1f5      	bne.n	8000c06 <HAL_RCC_ClockConfig+0x19e>
 8000c1a:	e778      	b.n	8000b0e <HAL_RCC_ClockConfig+0xa6>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI48)
 8000c1c:	3309      	adds	r3, #9
 8000c1e:	4698      	mov	r8, r3
        if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000c20:	4b0b      	ldr	r3, [pc, #44]	; (8000c50 <HAL_RCC_ClockConfig+0x1e8>)
 8000c22:	4699      	mov	r9, r3
 8000c24:	e004      	b.n	8000c30 <HAL_RCC_ClockConfig+0x1c8>
 8000c26:	f7ff fb25 	bl	8000274 <HAL_GetTick>
 8000c2a:	1bc0      	subs	r0, r0, r7
 8000c2c:	4548      	cmp	r0, r9
 8000c2e:	d8ce      	bhi.n	8000bce <HAL_RCC_ClockConfig+0x166>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI48)
 8000c30:	4642      	mov	r2, r8
 8000c32:	6873      	ldr	r3, [r6, #4]
 8000c34:	4013      	ands	r3, r2
 8000c36:	2b0c      	cmp	r3, #12
 8000c38:	d1f5      	bne.n	8000c26 <HAL_RCC_ClockConfig+0x1be>
 8000c3a:	e768      	b.n	8000b0e <HAL_RCC_ClockConfig+0xa6>
        pllclk = (HSI48_VALUE / prediv) * pllmul;
 8000c3c:	480b      	ldr	r0, [pc, #44]	; (8000c6c <HAL_RCC_ClockConfig+0x204>)
 8000c3e:	f7ff fa63 	bl	8000108 <__udivsi3>
 8000c42:	4360      	muls	r0, r4
 8000c44:	e790      	b.n	8000b68 <HAL_RCC_ClockConfig+0x100>
 8000c46:	46c0      	nop			; (mov r8, r8)
 8000c48:	40022000 	.word	0x40022000
 8000c4c:	40021000 	.word	0x40021000
 8000c50:	00001388 	.word	0x00001388
 8000c54:	08001f00 	.word	0x08001f00
 8000c58:	02625a00 	.word	0x02625a00
 8000c5c:	007a1200 	.word	0x007a1200
 8000c60:	08001f24 	.word	0x08001f24
 8000c64:	20000000 	.word	0x20000000
 8000c68:	fffff8ff 	.word	0xfffff8ff
 8000c6c:	02dc6c00 	.word	0x02dc6c00

08000c70 <HAL_RCC_GetSysClockFreq>:
{
 8000c70:	b570      	push	{r4, r5, r6, lr}
 8000c72:	b088      	sub	sp, #32
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000c74:	4669      	mov	r1, sp
 8000c76:	4b1c      	ldr	r3, [pc, #112]	; (8000ce8 <HAL_RCC_GetSysClockFreq+0x78>)
 8000c78:	000a      	movs	r2, r1
 8000c7a:	0018      	movs	r0, r3
 8000c7c:	c870      	ldmia	r0!, {r4, r5, r6}
 8000c7e:	c270      	stmia	r2!, {r4, r5, r6}
 8000c80:	6800      	ldr	r0, [r0, #0]
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000c82:	3310      	adds	r3, #16
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000c84:	6010      	str	r0, [r2, #0]
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000c86:	aa04      	add	r2, sp, #16
 8000c88:	0010      	movs	r0, r2
 8000c8a:	cb70      	ldmia	r3!, {r4, r5, r6}
 8000c8c:	c070      	stmia	r0!, {r4, r5, r6}
 8000c8e:	681b      	ldr	r3, [r3, #0]
  tmpreg = RCC->CFGR;
 8000c90:	4d16      	ldr	r5, [pc, #88]	; (8000cec <HAL_RCC_GetSysClockFreq+0x7c>)
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000c92:	6003      	str	r3, [r0, #0]
  switch (tmpreg & RCC_CFGR_SWS)
 8000c94:	200c      	movs	r0, #12
  tmpreg = RCC->CFGR;
 8000c96:	686b      	ldr	r3, [r5, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8000c98:	4018      	ands	r0, r3
 8000c9a:	2808      	cmp	r0, #8
 8000c9c:	d00a      	beq.n	8000cb4 <HAL_RCC_GetSysClockFreq+0x44>
      sysclockfreq = HSE_VALUE;
 8000c9e:	380c      	subs	r0, #12
 8000ca0:	4243      	negs	r3, r0
 8000ca2:	4158      	adcs	r0, r3
 8000ca4:	4b12      	ldr	r3, [pc, #72]	; (8000cf0 <HAL_RCC_GetSysClockFreq+0x80>)
 8000ca6:	4240      	negs	r0, r0
 8000ca8:	4018      	ands	r0, r3
 8000caa:	4b12      	ldr	r3, [pc, #72]	; (8000cf4 <HAL_RCC_GetSysClockFreq+0x84>)
 8000cac:	469c      	mov	ip, r3
 8000cae:	4460      	add	r0, ip
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8000cb0:	b008      	add	sp, #32
 8000cb2:	bd70      	pop	{r4, r5, r6, pc}
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8000cb4:	200f      	movs	r0, #15
 8000cb6:	0c9c      	lsrs	r4, r3, #18
 8000cb8:	4004      	ands	r4, r0
 8000cba:	5d0c      	ldrb	r4, [r1, r4]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8000cbc:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8000cbe:	4008      	ands	r0, r1
 8000cc0:	5c11      	ldrb	r1, [r2, r0]
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8000cc2:	22c0      	movs	r2, #192	; 0xc0
 8000cc4:	2080      	movs	r0, #128	; 0x80
 8000cc6:	0252      	lsls	r2, r2, #9
 8000cc8:	4013      	ands	r3, r2
 8000cca:	0240      	lsls	r0, r0, #9
 8000ccc:	4283      	cmp	r3, r0
 8000cce:	d001      	beq.n	8000cd4 <HAL_RCC_GetSysClockFreq+0x64>
      else if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSI48)
 8000cd0:	4293      	cmp	r3, r2
 8000cd2:	d004      	beq.n	8000cde <HAL_RCC_GetSysClockFreq+0x6e>
        pllclk = (HSI_VALUE / prediv) * pllmul;
 8000cd4:	4807      	ldr	r0, [pc, #28]	; (8000cf4 <HAL_RCC_GetSysClockFreq+0x84>)
 8000cd6:	f7ff fa17 	bl	8000108 <__udivsi3>
 8000cda:	4360      	muls	r0, r4
 8000cdc:	e7e8      	b.n	8000cb0 <HAL_RCC_GetSysClockFreq+0x40>
        pllclk = (HSI48_VALUE / prediv) * pllmul;
 8000cde:	4806      	ldr	r0, [pc, #24]	; (8000cf8 <HAL_RCC_GetSysClockFreq+0x88>)
 8000ce0:	f7ff fa12 	bl	8000108 <__udivsi3>
 8000ce4:	4360      	muls	r0, r4
 8000ce6:	e7e3      	b.n	8000cb0 <HAL_RCC_GetSysClockFreq+0x40>
 8000ce8:	08001f00 	.word	0x08001f00
 8000cec:	40021000 	.word	0x40021000
 8000cf0:	02625a00 	.word	0x02625a00
 8000cf4:	007a1200 	.word	0x007a1200
 8000cf8:	02dc6c00 	.word	0x02dc6c00

08000cfc <HAL_RCC_GetHCLKFreq>:
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 8000cfc:	4b01      	ldr	r3, [pc, #4]	; (8000d04 <HAL_RCC_GetHCLKFreq+0x8>)
 8000cfe:	6818      	ldr	r0, [r3, #0]
}
 8000d00:	4770      	bx	lr
 8000d02:	46c0      	nop			; (mov r8, r8)
 8000d04:	20000000 	.word	0x20000000

08000d08 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
 8000d08:	4b04      	ldr	r3, [pc, #16]	; (8000d1c <HAL_RCC_GetPCLK1Freq+0x14>)
 8000d0a:	4a05      	ldr	r2, [pc, #20]	; (8000d20 <HAL_RCC_GetPCLK1Freq+0x18>)
 8000d0c:	685b      	ldr	r3, [r3, #4]
 8000d0e:	055b      	lsls	r3, r3, #21
 8000d10:	0f5b      	lsrs	r3, r3, #29
 8000d12:	5cd3      	ldrb	r3, [r2, r3]
 8000d14:	4a03      	ldr	r2, [pc, #12]	; (8000d24 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8000d16:	6810      	ldr	r0, [r2, #0]
 8000d18:	40d8      	lsrs	r0, r3
}    
 8000d1a:	4770      	bx	lr
 8000d1c:	40021000 	.word	0x40021000
 8000d20:	08001f34 	.word	0x08001f34
 8000d24:	20000000 	.word	0x20000000

08000d28 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8000d28:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000d2a:	46ce      	mov	lr, r9
 8000d2c:	4647      	mov	r7, r8
 8000d2e:	b580      	push	{r7, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8000d30:	6803      	ldr	r3, [r0, #0]
{
 8000d32:	b083      	sub	sp, #12
 8000d34:	0004      	movs	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8000d36:	03da      	lsls	r2, r3, #15
 8000d38:	d536      	bpl.n	8000da8 <HAL_RCCEx_PeriphCLKConfig+0x80>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000d3a:	2280      	movs	r2, #128	; 0x80
 8000d3c:	4b49      	ldr	r3, [pc, #292]	; (8000e64 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 8000d3e:	0552      	lsls	r2, r2, #21
 8000d40:	69d9      	ldr	r1, [r3, #28]
    FlagStatus       pwrclkchanged = RESET;
 8000d42:	2700      	movs	r7, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000d44:	4211      	tst	r1, r2
 8000d46:	d107      	bne.n	8000d58 <HAL_RCCEx_PeriphCLKConfig+0x30>
    {
    __HAL_RCC_PWR_CLK_ENABLE();
 8000d48:	69d9      	ldr	r1, [r3, #28]
      pwrclkchanged = SET;
 8000d4a:	3701      	adds	r7, #1
    __HAL_RCC_PWR_CLK_ENABLE();
 8000d4c:	4311      	orrs	r1, r2
 8000d4e:	61d9      	str	r1, [r3, #28]
 8000d50:	69db      	ldr	r3, [r3, #28]
 8000d52:	401a      	ands	r2, r3
 8000d54:	9201      	str	r2, [sp, #4]
 8000d56:	9b01      	ldr	r3, [sp, #4]
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000d58:	2680      	movs	r6, #128	; 0x80
 8000d5a:	4d43      	ldr	r5, [pc, #268]	; (8000e68 <HAL_RCCEx_PeriphCLKConfig+0x140>)
 8000d5c:	0076      	lsls	r6, r6, #1
 8000d5e:	682b      	ldr	r3, [r5, #0]
 8000d60:	4233      	tst	r3, r6
 8000d62:	d054      	beq.n	8000e0e <HAL_RCCEx_PeriphCLKConfig+0xe6>
        }
      }
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8000d64:	21c0      	movs	r1, #192	; 0xc0
 8000d66:	4d3f      	ldr	r5, [pc, #252]	; (8000e64 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 8000d68:	0089      	lsls	r1, r1, #2
 8000d6a:	6a2a      	ldr	r2, [r5, #32]
 8000d6c:	6860      	ldr	r0, [r4, #4]
 8000d6e:	400a      	ands	r2, r1
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8000d70:	d011      	beq.n	8000d96 <HAL_RCCEx_PeriphCLKConfig+0x6e>
 8000d72:	4001      	ands	r1, r0
 8000d74:	4291      	cmp	r1, r2
 8000d76:	d00e      	beq.n	8000d96 <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8000d78:	2280      	movs	r2, #128	; 0x80
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8000d7a:	6a29      	ldr	r1, [r5, #32]
      __HAL_RCC_BACKUPRESET_FORCE();
 8000d7c:	6a2e      	ldr	r6, [r5, #32]
 8000d7e:	0252      	lsls	r2, r2, #9
 8000d80:	4332      	orrs	r2, r6
 8000d82:	622a      	str	r2, [r5, #32]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8000d84:	6a2a      	ldr	r2, [r5, #32]
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8000d86:	4b39      	ldr	r3, [pc, #228]	; (8000e6c <HAL_RCCEx_PeriphCLKConfig+0x144>)
      __HAL_RCC_BACKUPRESET_RELEASE();
 8000d88:	4e39      	ldr	r6, [pc, #228]	; (8000e70 <HAL_RCCEx_PeriphCLKConfig+0x148>)
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8000d8a:	400b      	ands	r3, r1
      __HAL_RCC_BACKUPRESET_RELEASE();
 8000d8c:	4032      	ands	r2, r6
 8000d8e:	622a      	str	r2, [r5, #32]
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;
 8000d90:	622b      	str	r3, [r5, #32]
      
      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 8000d92:	07cb      	lsls	r3, r1, #31
 8000d94:	d454      	bmi.n	8000e40 <HAL_RCCEx_PeriphCLKConfig+0x118>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8000d96:	4a33      	ldr	r2, [pc, #204]	; (8000e64 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 8000d98:	4934      	ldr	r1, [pc, #208]	; (8000e6c <HAL_RCCEx_PeriphCLKConfig+0x144>)
 8000d9a:	6a13      	ldr	r3, [r2, #32]
 8000d9c:	400b      	ands	r3, r1
 8000d9e:	4303      	orrs	r3, r0
 8000da0:	6213      	str	r3, [r2, #32]

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8000da2:	2f01      	cmp	r7, #1
 8000da4:	d044      	beq.n	8000e30 <HAL_RCCEx_PeriphCLKConfig+0x108>
 8000da6:	6823      	ldr	r3, [r4, #0]
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*------------------------------- USART1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8000da8:	07da      	lsls	r2, r3, #31
 8000daa:	d506      	bpl.n	8000dba <HAL_RCCEx_PeriphCLKConfig+0x92>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8000dac:	2003      	movs	r0, #3
 8000dae:	492d      	ldr	r1, [pc, #180]	; (8000e64 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 8000db0:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 8000db2:	4382      	bics	r2, r0
 8000db4:	68a0      	ldr	r0, [r4, #8]
 8000db6:	4302      	orrs	r2, r0
 8000db8:	630a      	str	r2, [r1, #48]	; 0x30
  }
  
#if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
 || defined(STM32F091xC) || defined(STM32F098xx)
  /*----------------------------- USART2 Configuration --------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8000dba:	079a      	lsls	r2, r3, #30
 8000dbc:	d506      	bpl.n	8000dcc <HAL_RCCEx_PeriphCLKConfig+0xa4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8000dbe:	4929      	ldr	r1, [pc, #164]	; (8000e64 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 8000dc0:	482c      	ldr	r0, [pc, #176]	; (8000e74 <HAL_RCCEx_PeriphCLKConfig+0x14c>)
 8000dc2:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 8000dc4:	4002      	ands	r2, r0
 8000dc6:	68e0      	ldr	r0, [r4, #12]
 8000dc8:	4302      	orrs	r2, r0
 8000dca:	630a      	str	r2, [r1, #48]	; 0x30
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
  }
#endif /* STM32F091xC || STM32F098xx */  

  /*------------------------------ I2C1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8000dcc:	069a      	lsls	r2, r3, #26
 8000dce:	d506      	bpl.n	8000dde <HAL_RCCEx_PeriphCLKConfig+0xb6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8000dd0:	2010      	movs	r0, #16
 8000dd2:	4924      	ldr	r1, [pc, #144]	; (8000e64 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 8000dd4:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 8000dd6:	4382      	bics	r2, r0
 8000dd8:	6920      	ldr	r0, [r4, #16]
 8000dda:	4302      	orrs	r2, r0
 8000ddc:	630a      	str	r2, [r1, #48]	; 0x30
  }

#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F070x6)
  /*------------------------------ USB Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8000dde:	039a      	lsls	r2, r3, #14
 8000de0:	d506      	bpl.n	8000df0 <HAL_RCCEx_PeriphCLKConfig+0xc8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8000de2:	2080      	movs	r0, #128	; 0x80
 8000de4:	491f      	ldr	r1, [pc, #124]	; (8000e64 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 8000de6:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 8000de8:	4382      	bics	r2, r0
 8000dea:	69a0      	ldr	r0, [r4, #24]
 8000dec:	4302      	orrs	r2, r0
 8000dee:	630a      	str	r2, [r1, #48]	; 0x30
#endif /* STM32F042x6 || STM32F048xx ||                */
       /* STM32F051x8 || STM32F058xx ||                */
       /* STM32F071xB || STM32F072xB || STM32F078xx || */
       /* STM32F091xC || STM32F098xx */
  
  return HAL_OK;
 8000df0:	2000      	movs	r0, #0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8000df2:	055b      	lsls	r3, r3, #21
 8000df4:	d506      	bpl.n	8000e04 <HAL_RCCEx_PeriphCLKConfig+0xdc>
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8000df6:	2140      	movs	r1, #64	; 0x40
 8000df8:	4a1a      	ldr	r2, [pc, #104]	; (8000e64 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 8000dfa:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8000dfc:	438b      	bics	r3, r1
 8000dfe:	6961      	ldr	r1, [r4, #20]
 8000e00:	430b      	orrs	r3, r1
 8000e02:	6313      	str	r3, [r2, #48]	; 0x30
}
 8000e04:	b003      	add	sp, #12
 8000e06:	bc0c      	pop	{r2, r3}
 8000e08:	4690      	mov	r8, r2
 8000e0a:	4699      	mov	r9, r3
 8000e0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8000e0e:	682b      	ldr	r3, [r5, #0]
 8000e10:	4333      	orrs	r3, r6
 8000e12:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 8000e14:	f7ff fa2e 	bl	8000274 <HAL_GetTick>
 8000e18:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000e1a:	e005      	b.n	8000e28 <HAL_RCCEx_PeriphCLKConfig+0x100>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000e1c:	f7ff fa2a 	bl	8000274 <HAL_GetTick>
 8000e20:	4643      	mov	r3, r8
 8000e22:	1ac0      	subs	r0, r0, r3
 8000e24:	2864      	cmp	r0, #100	; 0x64
 8000e26:	d809      	bhi.n	8000e3c <HAL_RCCEx_PeriphCLKConfig+0x114>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000e28:	682b      	ldr	r3, [r5, #0]
 8000e2a:	4233      	tst	r3, r6
 8000e2c:	d0f6      	beq.n	8000e1c <HAL_RCCEx_PeriphCLKConfig+0xf4>
 8000e2e:	e799      	b.n	8000d64 <HAL_RCCEx_PeriphCLKConfig+0x3c>
      __HAL_RCC_PWR_CLK_DISABLE();
 8000e30:	69d3      	ldr	r3, [r2, #28]
 8000e32:	4911      	ldr	r1, [pc, #68]	; (8000e78 <HAL_RCCEx_PeriphCLKConfig+0x150>)
 8000e34:	400b      	ands	r3, r1
 8000e36:	61d3      	str	r3, [r2, #28]
 8000e38:	6823      	ldr	r3, [r4, #0]
 8000e3a:	e7b5      	b.n	8000da8 <HAL_RCCEx_PeriphCLKConfig+0x80>
          return HAL_TIMEOUT;
 8000e3c:	2003      	movs	r0, #3
 8000e3e:	e7e1      	b.n	8000e04 <HAL_RCCEx_PeriphCLKConfig+0xdc>
        tickstart = HAL_GetTick();
 8000e40:	f7ff fa18 	bl	8000274 <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000e44:	4b0d      	ldr	r3, [pc, #52]	; (8000e7c <HAL_RCCEx_PeriphCLKConfig+0x154>)
        tickstart = HAL_GetTick();
 8000e46:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000e48:	2602      	movs	r6, #2
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000e4a:	4699      	mov	r9, r3
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000e4c:	e005      	b.n	8000e5a <HAL_RCCEx_PeriphCLKConfig+0x132>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8000e4e:	f7ff fa11 	bl	8000274 <HAL_GetTick>
 8000e52:	4643      	mov	r3, r8
 8000e54:	1ac0      	subs	r0, r0, r3
 8000e56:	4548      	cmp	r0, r9
 8000e58:	d8f0      	bhi.n	8000e3c <HAL_RCCEx_PeriphCLKConfig+0x114>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000e5a:	6a2b      	ldr	r3, [r5, #32]
 8000e5c:	421e      	tst	r6, r3
 8000e5e:	d0f6      	beq.n	8000e4e <HAL_RCCEx_PeriphCLKConfig+0x126>
 8000e60:	6860      	ldr	r0, [r4, #4]
 8000e62:	e798      	b.n	8000d96 <HAL_RCCEx_PeriphCLKConfig+0x6e>
 8000e64:	40021000 	.word	0x40021000
 8000e68:	40007000 	.word	0x40007000
 8000e6c:	fffffcff 	.word	0xfffffcff
 8000e70:	fffeffff 	.word	0xfffeffff
 8000e74:	fffcffff 	.word	0xfffcffff
 8000e78:	efffffff 	.word	0xefffffff
 8000e7c:	00001388 	.word	0x00001388

08000e80 <HAL_TIM_Base_Init>:
  *         parameters in the TIM_HandleTypeDef and create the associated handle.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 8000e80:	b570      	push	{r4, r5, r6, lr}
 8000e82:	1e04      	subs	r4, r0, #0
  /* Check the TIM handle allocation */
  if(htim == NULL)
 8000e84:	d04a      	beq.n	8000f1c <HAL_TIM_Base_Init+0x9c>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if(htim->State == HAL_TIM_STATE_RESET)
 8000e86:	233d      	movs	r3, #61	; 0x3d
 8000e88:	5cc3      	ldrb	r3, [r0, r3]
 8000e8a:	b2db      	uxtb	r3, r3
 8000e8c:	2b00      	cmp	r3, #0
 8000e8e:	d024      	beq.n	8000eda <HAL_TIM_Base_Init+0x5a>
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 8000e90:	233d      	movs	r3, #61	; 0x3d
 8000e92:	2202      	movs	r2, #2
{
  uint32_t tmpcr1 = 0U;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8000e94:	4e2c      	ldr	r6, [pc, #176]	; (8000f48 <HAL_TIM_Base_Init+0xc8>)
  htim->State= HAL_TIM_STATE_BUSY;
 8000e96:	54e2      	strb	r2, [r4, r3]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8000e98:	6822      	ldr	r2, [r4, #0]
 8000e9a:	69a5      	ldr	r5, [r4, #24]
  tmpcr1 = TIMx->CR1;
 8000e9c:	6813      	ldr	r3, [r2, #0]
 8000e9e:	68e0      	ldr	r0, [r4, #12]
 8000ea0:	6861      	ldr	r1, [r4, #4]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8000ea2:	42b2      	cmp	r2, r6
 8000ea4:	d03c      	beq.n	8000f20 <HAL_TIM_Base_Init+0xa0>
 8000ea6:	2680      	movs	r6, #128	; 0x80
 8000ea8:	05f6      	lsls	r6, r6, #23
 8000eaa:	42b2      	cmp	r2, r6
 8000eac:	d01a      	beq.n	8000ee4 <HAL_TIM_Base_Init+0x64>
 8000eae:	4e27      	ldr	r6, [pc, #156]	; (8000f4c <HAL_TIM_Base_Init+0xcc>)
 8000eb0:	42b2      	cmp	r2, r6
 8000eb2:	d017      	beq.n	8000ee4 <HAL_TIM_Base_Init+0x64>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8000eb4:	4e26      	ldr	r6, [pc, #152]	; (8000f50 <HAL_TIM_Base_Init+0xd0>)
 8000eb6:	42b2      	cmp	r2, r6
 8000eb8:	d041      	beq.n	8000f3e <HAL_TIM_Base_Init+0xbe>
 8000eba:	4e26      	ldr	r6, [pc, #152]	; (8000f54 <HAL_TIM_Base_Init+0xd4>)
 8000ebc:	42b2      	cmp	r2, r6
 8000ebe:	d033      	beq.n	8000f28 <HAL_TIM_Base_Init+0xa8>
 8000ec0:	4e25      	ldr	r6, [pc, #148]	; (8000f58 <HAL_TIM_Base_Init+0xd8>)
 8000ec2:	42b2      	cmp	r2, r6
 8000ec4:	d030      	beq.n	8000f28 <HAL_TIM_Base_Init+0xa8>
 8000ec6:	4e25      	ldr	r6, [pc, #148]	; (8000f5c <HAL_TIM_Base_Init+0xdc>)
 8000ec8:	42b2      	cmp	r2, r6
 8000eca:	d02d      	beq.n	8000f28 <HAL_TIM_Base_Init+0xa8>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8000ecc:	2680      	movs	r6, #128	; 0x80
 8000ece:	43b3      	bics	r3, r6
 8000ed0:	432b      	orrs	r3, r5

  TIMx->CR1 = tmpcr1;
 8000ed2:	6013      	str	r3, [r2, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000ed4:	62d0      	str	r0, [r2, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8000ed6:	6291      	str	r1, [r2, #40]	; 0x28
 8000ed8:	e01a      	b.n	8000f10 <HAL_TIM_Base_Init+0x90>
    htim->Lock = HAL_UNLOCKED;
 8000eda:	223c      	movs	r2, #60	; 0x3c
 8000edc:	5483      	strb	r3, [r0, r2]
    HAL_TIM_Base_MspInit(htim);
 8000ede:	f000 ff05 	bl	8001cec <HAL_TIM_Base_MspInit>
 8000ee2:	e7d5      	b.n	8000e90 <HAL_TIM_Base_Init+0x10>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8000ee4:	2670      	movs	r6, #112	; 0x70
 8000ee6:	43b3      	bics	r3, r6
    tmpcr1 |= Structure->CounterMode;
 8000ee8:	68a6      	ldr	r6, [r4, #8]
 8000eea:	4333      	orrs	r3, r6
    tmpcr1 &= ~TIM_CR1_CKD;
 8000eec:	4e1c      	ldr	r6, [pc, #112]	; (8000f60 <HAL_TIM_Base_Init+0xe0>)
 8000eee:	4033      	ands	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000ef0:	6926      	ldr	r6, [r4, #16]
 8000ef2:	4333      	orrs	r3, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8000ef4:	2680      	movs	r6, #128	; 0x80
 8000ef6:	43b3      	bics	r3, r6
 8000ef8:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8000efa:	6013      	str	r3, [r2, #0]

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8000efc:	4b16      	ldr	r3, [pc, #88]	; (8000f58 <HAL_TIM_Base_Init+0xd8>)
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000efe:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8000f00:	6291      	str	r1, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8000f02:	429a      	cmp	r2, r3
 8000f04:	d002      	beq.n	8000f0c <HAL_TIM_Base_Init+0x8c>
 8000f06:	4b15      	ldr	r3, [pc, #84]	; (8000f5c <HAL_TIM_Base_Init+0xdc>)
 8000f08:	429a      	cmp	r2, r3
 8000f0a:	d101      	bne.n	8000f10 <HAL_TIM_Base_Init+0x90>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8000f0c:	6963      	ldr	r3, [r4, #20]
 8000f0e:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 8000f10:	2301      	movs	r3, #1
 8000f12:	6153      	str	r3, [r2, #20]
  htim->State= HAL_TIM_STATE_READY;
 8000f14:	223d      	movs	r2, #61	; 0x3d
  return HAL_OK;
 8000f16:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8000f18:	54a3      	strb	r3, [r4, r2]
}
 8000f1a:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8000f1c:	2001      	movs	r0, #1
 8000f1e:	e7fc      	b.n	8000f1a <HAL_TIM_Base_Init+0x9a>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8000f20:	2670      	movs	r6, #112	; 0x70
 8000f22:	43b3      	bics	r3, r6
    tmpcr1 |= Structure->CounterMode;
 8000f24:	68a6      	ldr	r6, [r4, #8]
 8000f26:	4333      	orrs	r3, r6
    tmpcr1 &= ~TIM_CR1_CKD;
 8000f28:	4e0d      	ldr	r6, [pc, #52]	; (8000f60 <HAL_TIM_Base_Init+0xe0>)
 8000f2a:	4033      	ands	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000f2c:	6926      	ldr	r6, [r4, #16]
 8000f2e:	4333      	orrs	r3, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8000f30:	2680      	movs	r6, #128	; 0x80
 8000f32:	43b3      	bics	r3, r6
 8000f34:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8000f36:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000f38:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8000f3a:	6291      	str	r1, [r2, #40]	; 0x28
 8000f3c:	e7e6      	b.n	8000f0c <HAL_TIM_Base_Init+0x8c>
    tmpcr1 &= ~TIM_CR1_CKD;
 8000f3e:	4e08      	ldr	r6, [pc, #32]	; (8000f60 <HAL_TIM_Base_Init+0xe0>)
 8000f40:	4033      	ands	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000f42:	6926      	ldr	r6, [r4, #16]
 8000f44:	4333      	orrs	r3, r6
 8000f46:	e7c1      	b.n	8000ecc <HAL_TIM_Base_Init+0x4c>
 8000f48:	40012c00 	.word	0x40012c00
 8000f4c:	40000400 	.word	0x40000400
 8000f50:	40002000 	.word	0x40002000
 8000f54:	40014000 	.word	0x40014000
 8000f58:	40014400 	.word	0x40014400
 8000f5c:	40014800 	.word	0x40014800
 8000f60:	fffffcff 	.word	0xfffffcff

08000f64 <HAL_TIM_PWM_MspInit>:
 8000f64:	4770      	bx	lr
 8000f66:	46c0      	nop			; (mov r8, r8)

08000f68 <HAL_TIM_PWM_Init>:
{
 8000f68:	b570      	push	{r4, r5, r6, lr}
 8000f6a:	1e04      	subs	r4, r0, #0
  if(htim == NULL)
 8000f6c:	d04a      	beq.n	8001004 <HAL_TIM_PWM_Init+0x9c>
  if(htim->State == HAL_TIM_STATE_RESET)
 8000f6e:	233d      	movs	r3, #61	; 0x3d
 8000f70:	5cc3      	ldrb	r3, [r0, r3]
 8000f72:	b2db      	uxtb	r3, r3
 8000f74:	2b00      	cmp	r3, #0
 8000f76:	d024      	beq.n	8000fc2 <HAL_TIM_PWM_Init+0x5a>
  htim->State= HAL_TIM_STATE_BUSY;
 8000f78:	233d      	movs	r3, #61	; 0x3d
 8000f7a:	2202      	movs	r2, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8000f7c:	4e2c      	ldr	r6, [pc, #176]	; (8001030 <HAL_TIM_PWM_Init+0xc8>)
  htim->State= HAL_TIM_STATE_BUSY;
 8000f7e:	54e2      	strb	r2, [r4, r3]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8000f80:	6822      	ldr	r2, [r4, #0]
 8000f82:	69a5      	ldr	r5, [r4, #24]
  tmpcr1 = TIMx->CR1;
 8000f84:	6813      	ldr	r3, [r2, #0]
 8000f86:	68e0      	ldr	r0, [r4, #12]
 8000f88:	6861      	ldr	r1, [r4, #4]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8000f8a:	42b2      	cmp	r2, r6
 8000f8c:	d03c      	beq.n	8001008 <HAL_TIM_PWM_Init+0xa0>
 8000f8e:	2680      	movs	r6, #128	; 0x80
 8000f90:	05f6      	lsls	r6, r6, #23
 8000f92:	42b2      	cmp	r2, r6
 8000f94:	d01a      	beq.n	8000fcc <HAL_TIM_PWM_Init+0x64>
 8000f96:	4e27      	ldr	r6, [pc, #156]	; (8001034 <HAL_TIM_PWM_Init+0xcc>)
 8000f98:	42b2      	cmp	r2, r6
 8000f9a:	d017      	beq.n	8000fcc <HAL_TIM_PWM_Init+0x64>
  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8000f9c:	4e26      	ldr	r6, [pc, #152]	; (8001038 <HAL_TIM_PWM_Init+0xd0>)
 8000f9e:	42b2      	cmp	r2, r6
 8000fa0:	d041      	beq.n	8001026 <HAL_TIM_PWM_Init+0xbe>
 8000fa2:	4e26      	ldr	r6, [pc, #152]	; (800103c <HAL_TIM_PWM_Init+0xd4>)
 8000fa4:	42b2      	cmp	r2, r6
 8000fa6:	d033      	beq.n	8001010 <HAL_TIM_PWM_Init+0xa8>
 8000fa8:	4e25      	ldr	r6, [pc, #148]	; (8001040 <HAL_TIM_PWM_Init+0xd8>)
 8000faa:	42b2      	cmp	r2, r6
 8000fac:	d030      	beq.n	8001010 <HAL_TIM_PWM_Init+0xa8>
 8000fae:	4e25      	ldr	r6, [pc, #148]	; (8001044 <HAL_TIM_PWM_Init+0xdc>)
 8000fb0:	42b2      	cmp	r2, r6
 8000fb2:	d02d      	beq.n	8001010 <HAL_TIM_PWM_Init+0xa8>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8000fb4:	2680      	movs	r6, #128	; 0x80
 8000fb6:	43b3      	bics	r3, r6
 8000fb8:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8000fba:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000fbc:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8000fbe:	6291      	str	r1, [r2, #40]	; 0x28
 8000fc0:	e01a      	b.n	8000ff8 <HAL_TIM_PWM_Init+0x90>
    htim->Lock = HAL_UNLOCKED;
 8000fc2:	223c      	movs	r2, #60	; 0x3c
 8000fc4:	5483      	strb	r3, [r0, r2]
    HAL_TIM_PWM_MspInit(htim);
 8000fc6:	f7ff ffcd 	bl	8000f64 <HAL_TIM_PWM_MspInit>
 8000fca:	e7d5      	b.n	8000f78 <HAL_TIM_PWM_Init+0x10>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8000fcc:	2670      	movs	r6, #112	; 0x70
 8000fce:	43b3      	bics	r3, r6
    tmpcr1 |= Structure->CounterMode;
 8000fd0:	68a6      	ldr	r6, [r4, #8]
 8000fd2:	4333      	orrs	r3, r6
    tmpcr1 &= ~TIM_CR1_CKD;
 8000fd4:	4e1c      	ldr	r6, [pc, #112]	; (8001048 <HAL_TIM_PWM_Init+0xe0>)
 8000fd6:	4033      	ands	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000fd8:	6926      	ldr	r6, [r4, #16]
 8000fda:	4333      	orrs	r3, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8000fdc:	2680      	movs	r6, #128	; 0x80
 8000fde:	43b3      	bics	r3, r6
 8000fe0:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8000fe2:	6013      	str	r3, [r2, #0]
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8000fe4:	4b16      	ldr	r3, [pc, #88]	; (8001040 <HAL_TIM_PWM_Init+0xd8>)
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000fe6:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8000fe8:	6291      	str	r1, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8000fea:	429a      	cmp	r2, r3
 8000fec:	d002      	beq.n	8000ff4 <HAL_TIM_PWM_Init+0x8c>
 8000fee:	4b15      	ldr	r3, [pc, #84]	; (8001044 <HAL_TIM_PWM_Init+0xdc>)
 8000ff0:	429a      	cmp	r2, r3
 8000ff2:	d101      	bne.n	8000ff8 <HAL_TIM_PWM_Init+0x90>
    TIMx->RCR = Structure->RepetitionCounter;
 8000ff4:	6963      	ldr	r3, [r4, #20]
 8000ff6:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8000ff8:	2301      	movs	r3, #1
 8000ffa:	6153      	str	r3, [r2, #20]
  htim->State= HAL_TIM_STATE_READY;
 8000ffc:	223d      	movs	r2, #61	; 0x3d
  return HAL_OK;
 8000ffe:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8001000:	54a3      	strb	r3, [r4, r2]
}
 8001002:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8001004:	2001      	movs	r0, #1
 8001006:	e7fc      	b.n	8001002 <HAL_TIM_PWM_Init+0x9a>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001008:	2670      	movs	r6, #112	; 0x70
 800100a:	43b3      	bics	r3, r6
    tmpcr1 |= Structure->CounterMode;
 800100c:	68a6      	ldr	r6, [r4, #8]
 800100e:	4333      	orrs	r3, r6
    tmpcr1 &= ~TIM_CR1_CKD;
 8001010:	4e0d      	ldr	r6, [pc, #52]	; (8001048 <HAL_TIM_PWM_Init+0xe0>)
 8001012:	4033      	ands	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001014:	6926      	ldr	r6, [r4, #16]
 8001016:	4333      	orrs	r3, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8001018:	2680      	movs	r6, #128	; 0x80
 800101a:	43b3      	bics	r3, r6
 800101c:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 800101e:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001020:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8001022:	6291      	str	r1, [r2, #40]	; 0x28
 8001024:	e7e6      	b.n	8000ff4 <HAL_TIM_PWM_Init+0x8c>
    tmpcr1 &= ~TIM_CR1_CKD;
 8001026:	4e08      	ldr	r6, [pc, #32]	; (8001048 <HAL_TIM_PWM_Init+0xe0>)
 8001028:	4033      	ands	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800102a:	6926      	ldr	r6, [r4, #16]
 800102c:	4333      	orrs	r3, r6
 800102e:	e7c1      	b.n	8000fb4 <HAL_TIM_PWM_Init+0x4c>
 8001030:	40012c00 	.word	0x40012c00
 8001034:	40000400 	.word	0x40000400
 8001038:	40002000 	.word	0x40002000
 800103c:	40014000 	.word	0x40014000
 8001040:	40014400 	.word	0x40014400
 8001044:	40014800 	.word	0x40014800
 8001048:	fffffcff 	.word	0xfffffcff

0800104c <HAL_TIM_OnePulse_MspInit>:
 800104c:	4770      	bx	lr
 800104e:	46c0      	nop			; (mov r8, r8)

08001050 <HAL_TIM_OnePulse_Init>:
{
 8001050:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001052:	0004      	movs	r4, r0
 8001054:	000d      	movs	r5, r1
  if(htim == NULL)
 8001056:	2800      	cmp	r0, #0
 8001058:	d051      	beq.n	80010fe <HAL_TIM_OnePulse_Init+0xae>
  if(htim->State == HAL_TIM_STATE_RESET)
 800105a:	233d      	movs	r3, #61	; 0x3d
 800105c:	5cc3      	ldrb	r3, [r0, r3]
 800105e:	b2db      	uxtb	r3, r3
 8001060:	2b00      	cmp	r3, #0
 8001062:	d024      	beq.n	80010ae <HAL_TIM_OnePulse_Init+0x5e>
  htim->State= HAL_TIM_STATE_BUSY;
 8001064:	233d      	movs	r3, #61	; 0x3d
 8001066:	2202      	movs	r2, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001068:	4f30      	ldr	r7, [pc, #192]	; (800112c <HAL_TIM_OnePulse_Init+0xdc>)
  htim->State= HAL_TIM_STATE_BUSY;
 800106a:	54e2      	strb	r2, [r4, r3]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800106c:	6823      	ldr	r3, [r4, #0]
 800106e:	69a6      	ldr	r6, [r4, #24]
  tmpcr1 = TIMx->CR1;
 8001070:	681a      	ldr	r2, [r3, #0]
 8001072:	68e0      	ldr	r0, [r4, #12]
 8001074:	6861      	ldr	r1, [r4, #4]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001076:	42bb      	cmp	r3, r7
 8001078:	d043      	beq.n	8001102 <HAL_TIM_OnePulse_Init+0xb2>
 800107a:	2780      	movs	r7, #128	; 0x80
 800107c:	05ff      	lsls	r7, r7, #23
 800107e:	42bb      	cmp	r3, r7
 8001080:	d01a      	beq.n	80010b8 <HAL_TIM_OnePulse_Init+0x68>
 8001082:	4f2b      	ldr	r7, [pc, #172]	; (8001130 <HAL_TIM_OnePulse_Init+0xe0>)
 8001084:	42bb      	cmp	r3, r7
 8001086:	d017      	beq.n	80010b8 <HAL_TIM_OnePulse_Init+0x68>
  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8001088:	4f2a      	ldr	r7, [pc, #168]	; (8001134 <HAL_TIM_OnePulse_Init+0xe4>)
 800108a:	42bb      	cmp	r3, r7
 800108c:	d048      	beq.n	8001120 <HAL_TIM_OnePulse_Init+0xd0>
 800108e:	4f2a      	ldr	r7, [pc, #168]	; (8001138 <HAL_TIM_OnePulse_Init+0xe8>)
 8001090:	42bb      	cmp	r3, r7
 8001092:	d03a      	beq.n	800110a <HAL_TIM_OnePulse_Init+0xba>
 8001094:	4f29      	ldr	r7, [pc, #164]	; (800113c <HAL_TIM_OnePulse_Init+0xec>)
 8001096:	42bb      	cmp	r3, r7
 8001098:	d037      	beq.n	800110a <HAL_TIM_OnePulse_Init+0xba>
 800109a:	4f29      	ldr	r7, [pc, #164]	; (8001140 <HAL_TIM_OnePulse_Init+0xf0>)
 800109c:	42bb      	cmp	r3, r7
 800109e:	d034      	beq.n	800110a <HAL_TIM_OnePulse_Init+0xba>
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80010a0:	2780      	movs	r7, #128	; 0x80
 80010a2:	43ba      	bics	r2, r7
 80010a4:	4332      	orrs	r2, r6
  TIMx->CR1 = tmpcr1;
 80010a6:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80010a8:	62d8      	str	r0, [r3, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80010aa:	6299      	str	r1, [r3, #40]	; 0x28
 80010ac:	e01a      	b.n	80010e4 <HAL_TIM_OnePulse_Init+0x94>
    htim->Lock = HAL_UNLOCKED;
 80010ae:	223c      	movs	r2, #60	; 0x3c
 80010b0:	5483      	strb	r3, [r0, r2]
    HAL_TIM_OnePulse_MspInit(htim);
 80010b2:	f7ff ffcb 	bl	800104c <HAL_TIM_OnePulse_MspInit>
 80010b6:	e7d5      	b.n	8001064 <HAL_TIM_OnePulse_Init+0x14>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80010b8:	2770      	movs	r7, #112	; 0x70
 80010ba:	43ba      	bics	r2, r7
    tmpcr1 |= Structure->CounterMode;
 80010bc:	68a7      	ldr	r7, [r4, #8]
 80010be:	433a      	orrs	r2, r7
    tmpcr1 &= ~TIM_CR1_CKD;
 80010c0:	4f20      	ldr	r7, [pc, #128]	; (8001144 <HAL_TIM_OnePulse_Init+0xf4>)
 80010c2:	403a      	ands	r2, r7
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80010c4:	6927      	ldr	r7, [r4, #16]
 80010c6:	433a      	orrs	r2, r7
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80010c8:	2780      	movs	r7, #128	; 0x80
 80010ca:	43ba      	bics	r2, r7
 80010cc:	4332      	orrs	r2, r6
  TIMx->CR1 = tmpcr1;
 80010ce:	601a      	str	r2, [r3, #0]
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80010d0:	4a1a      	ldr	r2, [pc, #104]	; (800113c <HAL_TIM_OnePulse_Init+0xec>)
  TIMx->ARR = (uint32_t)Structure->Period ;
 80010d2:	62d8      	str	r0, [r3, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80010d4:	6299      	str	r1, [r3, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80010d6:	4293      	cmp	r3, r2
 80010d8:	d002      	beq.n	80010e0 <HAL_TIM_OnePulse_Init+0x90>
 80010da:	4a19      	ldr	r2, [pc, #100]	; (8001140 <HAL_TIM_OnePulse_Init+0xf0>)
 80010dc:	4293      	cmp	r3, r2
 80010de:	d101      	bne.n	80010e4 <HAL_TIM_OnePulse_Init+0x94>
    TIMx->RCR = Structure->RepetitionCounter;
 80010e0:	6962      	ldr	r2, [r4, #20]
 80010e2:	631a      	str	r2, [r3, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 80010e4:	2001      	movs	r0, #1
  htim->Instance->CR1 &= ~TIM_CR1_OPM;
 80010e6:	2108      	movs	r1, #8
  TIMx->EGR = TIM_EGR_UG;
 80010e8:	6158      	str	r0, [r3, #20]
  htim->Instance->CR1 &= ~TIM_CR1_OPM;
 80010ea:	681a      	ldr	r2, [r3, #0]
 80010ec:	438a      	bics	r2, r1
 80010ee:	601a      	str	r2, [r3, #0]
  htim->Instance->CR1 |= OnePulseMode;
 80010f0:	6819      	ldr	r1, [r3, #0]
 80010f2:	4329      	orrs	r1, r5
 80010f4:	6019      	str	r1, [r3, #0]
  htim->State= HAL_TIM_STATE_READY;
 80010f6:	233d      	movs	r3, #61	; 0x3d
 80010f8:	54e0      	strb	r0, [r4, r3]
  return HAL_OK;
 80010fa:	2000      	movs	r0, #0
}
 80010fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80010fe:	2001      	movs	r0, #1
 8001100:	e7fc      	b.n	80010fc <HAL_TIM_OnePulse_Init+0xac>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001102:	2770      	movs	r7, #112	; 0x70
 8001104:	43ba      	bics	r2, r7
    tmpcr1 |= Structure->CounterMode;
 8001106:	68a7      	ldr	r7, [r4, #8]
 8001108:	433a      	orrs	r2, r7
    tmpcr1 &= ~TIM_CR1_CKD;
 800110a:	4f0e      	ldr	r7, [pc, #56]	; (8001144 <HAL_TIM_OnePulse_Init+0xf4>)
 800110c:	403a      	ands	r2, r7
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800110e:	6927      	ldr	r7, [r4, #16]
 8001110:	433a      	orrs	r2, r7
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8001112:	2780      	movs	r7, #128	; 0x80
 8001114:	43ba      	bics	r2, r7
 8001116:	4332      	orrs	r2, r6
  TIMx->CR1 = tmpcr1;
 8001118:	601a      	str	r2, [r3, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800111a:	62d8      	str	r0, [r3, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 800111c:	6299      	str	r1, [r3, #40]	; 0x28
 800111e:	e7df      	b.n	80010e0 <HAL_TIM_OnePulse_Init+0x90>
    tmpcr1 &= ~TIM_CR1_CKD;
 8001120:	4f08      	ldr	r7, [pc, #32]	; (8001144 <HAL_TIM_OnePulse_Init+0xf4>)
 8001122:	403a      	ands	r2, r7
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001124:	6927      	ldr	r7, [r4, #16]
 8001126:	433a      	orrs	r2, r7
 8001128:	e7ba      	b.n	80010a0 <HAL_TIM_OnePulse_Init+0x50>
 800112a:	46c0      	nop			; (mov r8, r8)
 800112c:	40012c00 	.word	0x40012c00
 8001130:	40000400 	.word	0x40000400
 8001134:	40002000 	.word	0x40002000
 8001138:	40014000 	.word	0x40014000
 800113c:	40014400 	.word	0x40014400
 8001140:	40014800 	.word	0x40014800
 8001144:	fffffcff 	.word	0xfffffcff

08001148 <HAL_TIM_PWM_ConfigChannel>:
  __HAL_LOCK(htim);
 8001148:	233c      	movs	r3, #60	; 0x3c
{
 800114a:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
 800114c:	5cc4      	ldrb	r4, [r0, r3]
 800114e:	2c01      	cmp	r4, #1
 8001150:	d100      	bne.n	8001154 <HAL_TIM_PWM_ConfigChannel+0xc>
 8001152:	e087      	b.n	8001264 <HAL_TIM_PWM_ConfigChannel+0x11c>
 8001154:	2501      	movs	r5, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8001156:	2402      	movs	r4, #2
  __HAL_LOCK(htim);
 8001158:	54c5      	strb	r5, [r0, r3]
  htim->State = HAL_TIM_STATE_BUSY;
 800115a:	3301      	adds	r3, #1
 800115c:	54c4      	strb	r4, [r0, r3]
  switch (Channel)
 800115e:	2a04      	cmp	r2, #4
 8001160:	d100      	bne.n	8001164 <HAL_TIM_PWM_ConfigChannel+0x1c>
 8001162:	e0bf      	b.n	80012e4 <HAL_TIM_PWM_ConfigChannel+0x19c>
 8001164:	d93d      	bls.n	80011e2 <HAL_TIM_PWM_ConfigChannel+0x9a>
 8001166:	2a08      	cmp	r2, #8
 8001168:	d100      	bne.n	800116c <HAL_TIM_PWM_ConfigChannel+0x24>
 800116a:	e07d      	b.n	8001268 <HAL_TIM_PWM_ConfigChannel+0x120>
 800116c:	2a0c      	cmp	r2, #12
 800116e:	d130      	bne.n	80011d2 <HAL_TIM_PWM_ConfigChannel+0x8a>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8001170:	6803      	ldr	r3, [r0, #0]
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8001172:	4c7d      	ldr	r4, [pc, #500]	; (8001368 <HAL_TIM_PWM_ConfigChannel+0x220>)
 8001174:	6a1a      	ldr	r2, [r3, #32]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8001176:	4d7d      	ldr	r5, [pc, #500]	; (800136c <HAL_TIM_PWM_ConfigChannel+0x224>)
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8001178:	4022      	ands	r2, r4
 800117a:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 800117c:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 800117e:	685f      	ldr	r7, [r3, #4]
  tmpccmrx = TIMx->CCMR2;
 8001180:	69dc      	ldr	r4, [r3, #28]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8001182:	402c      	ands	r4, r5

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8001184:	680d      	ldr	r5, [r1, #0]
 8001186:	022d      	lsls	r5, r5, #8
 8001188:	4325      	orrs	r5, r4

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 800118a:	4c79      	ldr	r4, [pc, #484]	; (8001370 <HAL_TIM_PWM_ConfigChannel+0x228>)
 800118c:	4014      	ands	r4, r2
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800118e:	688a      	ldr	r2, [r1, #8]
 8001190:	0312      	lsls	r2, r2, #12
 8001192:	4322      	orrs	r2, r4

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8001194:	4c77      	ldr	r4, [pc, #476]	; (8001374 <HAL_TIM_PWM_ConfigChannel+0x22c>)
 8001196:	42a3      	cmp	r3, r4
 8001198:	d051      	beq.n	800123e <HAL_TIM_PWM_ConfigChannel+0xf6>
 800119a:	4c77      	ldr	r4, [pc, #476]	; (8001378 <HAL_TIM_PWM_ConfigChannel+0x230>)
 800119c:	42a3      	cmp	r3, r4
 800119e:	d04e      	beq.n	800123e <HAL_TIM_PWM_ConfigChannel+0xf6>
 80011a0:	4c76      	ldr	r4, [pc, #472]	; (800137c <HAL_TIM_PWM_ConfigChannel+0x234>)
 80011a2:	42a3      	cmp	r3, r4
 80011a4:	d04b      	beq.n	800123e <HAL_TIM_PWM_ConfigChannel+0xf6>
 80011a6:	4c76      	ldr	r4, [pc, #472]	; (8001380 <HAL_TIM_PWM_ConfigChannel+0x238>)
 80011a8:	42a3      	cmp	r3, r4
 80011aa:	d048      	beq.n	800123e <HAL_TIM_PWM_ConfigChannel+0xf6>

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 80011ac:	684c      	ldr	r4, [r1, #4]
  TIMx->CR2 = tmpcr2;
 80011ae:	605f      	str	r7, [r3, #4]
  TIMx->CCMR2 = tmpccmrx;
 80011b0:	61dd      	str	r5, [r3, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 80011b2:	641c      	str	r4, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80011b4:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80011b6:	2280      	movs	r2, #128	; 0x80
 80011b8:	69dc      	ldr	r4, [r3, #28]
 80011ba:	0112      	lsls	r2, r2, #4
 80011bc:	4322      	orrs	r2, r4
 80011be:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 80011c0:	69da      	ldr	r2, [r3, #28]
 80011c2:	4c70      	ldr	r4, [pc, #448]	; (8001384 <HAL_TIM_PWM_ConfigChannel+0x23c>)
 80011c4:	4022      	ands	r2, r4
 80011c6:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 80011c8:	690a      	ldr	r2, [r1, #16]
 80011ca:	69dc      	ldr	r4, [r3, #28]
 80011cc:	0212      	lsls	r2, r2, #8
 80011ce:	4322      	orrs	r2, r4
 80011d0:	61da      	str	r2, [r3, #28]
  htim->State = HAL_TIM_STATE_READY;
 80011d2:	233d      	movs	r3, #61	; 0x3d
 80011d4:	2201      	movs	r2, #1
 80011d6:	54c2      	strb	r2, [r0, r3]
  __HAL_UNLOCK(htim);
 80011d8:	2200      	movs	r2, #0
 80011da:	3b01      	subs	r3, #1
 80011dc:	54c2      	strb	r2, [r0, r3]
  return HAL_OK;
 80011de:	2000      	movs	r0, #0
}
 80011e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (Channel)
 80011e2:	2a00      	cmp	r2, #0
 80011e4:	d1f5      	bne.n	80011d2 <HAL_TIM_PWM_ConfigChannel+0x8a>
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80011e6:	2773      	movs	r7, #115	; 0x73
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 80011e8:	6803      	ldr	r3, [r0, #0]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80011ea:	6a1a      	ldr	r2, [r3, #32]
 80011ec:	43aa      	bics	r2, r5
 80011ee:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 80011f0:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 80011f2:	685e      	ldr	r6, [r3, #4]
  tmpccmrx = TIMx->CCMR1;
 80011f4:	699d      	ldr	r5, [r3, #24]
  tmpccer &= ~TIM_CCER_CC1P;
 80011f6:	43a2      	bics	r2, r4
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80011f8:	43bd      	bics	r5, r7
  tmpccmrx |= OC_Config->OCMode;
 80011fa:	680f      	ldr	r7, [r1, #0]
  tmpccer |= OC_Config->OCPolarity;
 80011fc:	688c      	ldr	r4, [r1, #8]
  tmpccmrx |= OC_Config->OCMode;
 80011fe:	433d      	orrs	r5, r7
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8001200:	4f5c      	ldr	r7, [pc, #368]	; (8001374 <HAL_TIM_PWM_ConfigChannel+0x22c>)
  tmpccer |= OC_Config->OCPolarity;
 8001202:	4322      	orrs	r2, r4
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8001204:	42bb      	cmp	r3, r7
 8001206:	d020      	beq.n	800124a <HAL_TIM_PWM_ConfigChannel+0x102>
 8001208:	4c5b      	ldr	r4, [pc, #364]	; (8001378 <HAL_TIM_PWM_ConfigChannel+0x230>)
 800120a:	42a3      	cmp	r3, r4
 800120c:	d01d      	beq.n	800124a <HAL_TIM_PWM_ConfigChannel+0x102>
 800120e:	4c5b      	ldr	r4, [pc, #364]	; (800137c <HAL_TIM_PWM_ConfigChannel+0x234>)
 8001210:	42a3      	cmp	r3, r4
 8001212:	d01a      	beq.n	800124a <HAL_TIM_PWM_ConfigChannel+0x102>
 8001214:	4c5a      	ldr	r4, [pc, #360]	; (8001380 <HAL_TIM_PWM_ConfigChannel+0x238>)
 8001216:	42a3      	cmp	r3, r4
 8001218:	d017      	beq.n	800124a <HAL_TIM_PWM_ConfigChannel+0x102>
  TIMx->CCR1 = OC_Config->Pulse;
 800121a:	684c      	ldr	r4, [r1, #4]
  TIMx->CR2 = tmpcr2;
 800121c:	605e      	str	r6, [r3, #4]
  TIMx->CCMR1 = tmpccmrx;
 800121e:	619d      	str	r5, [r3, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8001220:	635c      	str	r4, [r3, #52]	; 0x34
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8001222:	2408      	movs	r4, #8
  TIMx->CCER = tmpccer;
 8001224:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8001226:	699a      	ldr	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8001228:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800122a:	4322      	orrs	r2, r4
 800122c:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 800122e:	699a      	ldr	r2, [r3, #24]
 8001230:	3c04      	subs	r4, #4
 8001232:	43a2      	bics	r2, r4
 8001234:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8001236:	699a      	ldr	r2, [r3, #24]
 8001238:	430a      	orrs	r2, r1
 800123a:	619a      	str	r2, [r3, #24]
    break;
 800123c:	e7c9      	b.n	80011d2 <HAL_TIM_PWM_ConfigChannel+0x8a>
    tmpcr2 &= ~TIM_CR2_OIS4;
 800123e:	4e52      	ldr	r6, [pc, #328]	; (8001388 <HAL_TIM_PWM_ConfigChannel+0x240>)
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8001240:	694c      	ldr	r4, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS4;
 8001242:	403e      	ands	r6, r7
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8001244:	01a7      	lsls	r7, r4, #6
 8001246:	4337      	orrs	r7, r6
 8001248:	e7b0      	b.n	80011ac <HAL_TIM_PWM_ConfigChannel+0x64>
    tmpccer &= ~TIM_CCER_CC1NP;
 800124a:	2408      	movs	r4, #8
 800124c:	43a2      	bics	r2, r4
    tmpccer |= OC_Config->OCNPolarity;
 800124e:	68cc      	ldr	r4, [r1, #12]
    tmpcr2 |= OC_Config->OCNIdleState;
 8001250:	698f      	ldr	r7, [r1, #24]
    tmpccer |= OC_Config->OCNPolarity;
 8001252:	4322      	orrs	r2, r4
    tmpccer &= ~TIM_CCER_CC1NE;
 8001254:	2404      	movs	r4, #4
 8001256:	43a2      	bics	r2, r4
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8001258:	4c4c      	ldr	r4, [pc, #304]	; (800138c <HAL_TIM_PWM_ConfigChannel+0x244>)
 800125a:	4034      	ands	r4, r6
    tmpcr2 |= OC_Config->OCNIdleState;
 800125c:	694e      	ldr	r6, [r1, #20]
 800125e:	433e      	orrs	r6, r7
 8001260:	4326      	orrs	r6, r4
 8001262:	e7da      	b.n	800121a <HAL_TIM_PWM_ConfigChannel+0xd2>
  __HAL_LOCK(htim);
 8001264:	2002      	movs	r0, #2
 8001266:	e7bb      	b.n	80011e0 <HAL_TIM_PWM_ConfigChannel+0x98>
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8001268:	2673      	movs	r6, #115	; 0x73
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800126a:	6803      	ldr	r3, [r0, #0]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800126c:	4c48      	ldr	r4, [pc, #288]	; (8001390 <HAL_TIM_PWM_ConfigChannel+0x248>)
 800126e:	6a1a      	ldr	r2, [r3, #32]
  tmpccmrx |= OC_Config->OCMode;
 8001270:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8001272:	4022      	ands	r2, r4
 8001274:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 8001276:	6a1c      	ldr	r4, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 8001278:	685a      	ldr	r2, [r3, #4]
  tmpccmrx = TIMx->CCMR2;
 800127a:	69dd      	ldr	r5, [r3, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 800127c:	43b5      	bics	r5, r6
  tmpccmrx |= OC_Config->OCMode;
 800127e:	432f      	orrs	r7, r5
  tmpccer &= ~TIM_CCER_CC3P;
 8001280:	4d44      	ldr	r5, [pc, #272]	; (8001394 <HAL_TIM_PWM_ConfigChannel+0x24c>)
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8001282:	4e3c      	ldr	r6, [pc, #240]	; (8001374 <HAL_TIM_PWM_ConfigChannel+0x22c>)
  tmpccer &= ~TIM_CCER_CC3P;
 8001284:	402c      	ands	r4, r5
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8001286:	688d      	ldr	r5, [r1, #8]
 8001288:	022d      	lsls	r5, r5, #8
 800128a:	432c      	orrs	r4, r5
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800128c:	42b3      	cmp	r3, r6
 800128e:	d01a      	beq.n	80012c6 <HAL_TIM_PWM_ConfigChannel+0x17e>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8001290:	4e39      	ldr	r6, [pc, #228]	; (8001378 <HAL_TIM_PWM_ConfigChannel+0x230>)
 8001292:	42b3      	cmp	r3, r6
 8001294:	d01e      	beq.n	80012d4 <HAL_TIM_PWM_ConfigChannel+0x18c>
 8001296:	4d39      	ldr	r5, [pc, #228]	; (800137c <HAL_TIM_PWM_ConfigChannel+0x234>)
 8001298:	42ab      	cmp	r3, r5
 800129a:	d01b      	beq.n	80012d4 <HAL_TIM_PWM_ConfigChannel+0x18c>
 800129c:	4d38      	ldr	r5, [pc, #224]	; (8001380 <HAL_TIM_PWM_ConfigChannel+0x238>)
 800129e:	42ab      	cmp	r3, r5
 80012a0:	d018      	beq.n	80012d4 <HAL_TIM_PWM_ConfigChannel+0x18c>
  TIMx->CR2 = tmpcr2;
 80012a2:	605a      	str	r2, [r3, #4]
  TIMx->CCR3 = OC_Config->Pulse;
 80012a4:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 80012a6:	61df      	str	r7, [r3, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 80012a8:	63da      	str	r2, [r3, #60]	; 0x3c
  TIMx->CCER = tmpccer;
 80012aa:	621c      	str	r4, [r3, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80012ac:	2408      	movs	r4, #8
 80012ae:	69da      	ldr	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80012b0:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80012b2:	4322      	orrs	r2, r4
 80012b4:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 80012b6:	69da      	ldr	r2, [r3, #28]
 80012b8:	3c04      	subs	r4, #4
 80012ba:	43a2      	bics	r2, r4
 80012bc:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80012be:	69da      	ldr	r2, [r3, #28]
 80012c0:	430a      	orrs	r2, r1
 80012c2:	61da      	str	r2, [r3, #28]
    break;
 80012c4:	e785      	b.n	80011d2 <HAL_TIM_PWM_ConfigChannel+0x8a>
    tmpccer &= ~TIM_CCER_CC3NP;
 80012c6:	4d34      	ldr	r5, [pc, #208]	; (8001398 <HAL_TIM_PWM_ConfigChannel+0x250>)
 80012c8:	4025      	ands	r5, r4
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80012ca:	68cc      	ldr	r4, [r1, #12]
 80012cc:	0224      	lsls	r4, r4, #8
 80012ce:	432c      	orrs	r4, r5
    tmpccer &= ~TIM_CCER_CC3NE;
 80012d0:	4d2c      	ldr	r5, [pc, #176]	; (8001384 <HAL_TIM_PWM_ConfigChannel+0x23c>)
 80012d2:	402c      	ands	r4, r5
    tmpcr2 &= ~TIM_CR2_OIS3N;
 80012d4:	4e31      	ldr	r6, [pc, #196]	; (800139c <HAL_TIM_PWM_ConfigChannel+0x254>)
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80012d6:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 80012d8:	4016      	ands	r6, r2
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 80012da:	698a      	ldr	r2, [r1, #24]
 80012dc:	432a      	orrs	r2, r5
 80012de:	0112      	lsls	r2, r2, #4
 80012e0:	4332      	orrs	r2, r6
 80012e2:	e7de      	b.n	80012a2 <HAL_TIM_PWM_ConfigChannel+0x15a>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80012e4:	2410      	movs	r4, #16
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80012e6:	6803      	ldr	r3, [r0, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80012e8:	4e20      	ldr	r6, [pc, #128]	; (800136c <HAL_TIM_PWM_ConfigChannel+0x224>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80012ea:	6a1a      	ldr	r2, [r3, #32]
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80012ec:	4f21      	ldr	r7, [pc, #132]	; (8001374 <HAL_TIM_PWM_ConfigChannel+0x22c>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80012ee:	43a2      	bics	r2, r4
 80012f0:	621a      	str	r2, [r3, #32]
  tmpccer = TIMx->CCER;
 80012f2:	6a1c      	ldr	r4, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 80012f4:	685a      	ldr	r2, [r3, #4]
  tmpccmrx = TIMx->CCMR1;
 80012f6:	699d      	ldr	r5, [r3, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 80012f8:	4035      	ands	r5, r6
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80012fa:	680e      	ldr	r6, [r1, #0]
 80012fc:	0236      	lsls	r6, r6, #8
 80012fe:	432e      	orrs	r6, r5
  tmpccer &= ~TIM_CCER_CC2P;
 8001300:	2520      	movs	r5, #32
 8001302:	43ac      	bics	r4, r5
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8001304:	688d      	ldr	r5, [r1, #8]
 8001306:	012d      	lsls	r5, r5, #4
 8001308:	432c      	orrs	r4, r5
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800130a:	42bb      	cmp	r3, r7
 800130c:	d01c      	beq.n	8001348 <HAL_TIM_PWM_ConfigChannel+0x200>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 800130e:	4f1a      	ldr	r7, [pc, #104]	; (8001378 <HAL_TIM_PWM_ConfigChannel+0x230>)
 8001310:	42bb      	cmp	r3, r7
 8001312:	d021      	beq.n	8001358 <HAL_TIM_PWM_ConfigChannel+0x210>
 8001314:	4f19      	ldr	r7, [pc, #100]	; (800137c <HAL_TIM_PWM_ConfigChannel+0x234>)
 8001316:	42bb      	cmp	r3, r7
 8001318:	d01e      	beq.n	8001358 <HAL_TIM_PWM_ConfigChannel+0x210>
 800131a:	4d19      	ldr	r5, [pc, #100]	; (8001380 <HAL_TIM_PWM_ConfigChannel+0x238>)
 800131c:	42ab      	cmp	r3, r5
 800131e:	d01b      	beq.n	8001358 <HAL_TIM_PWM_ConfigChannel+0x210>
  TIMx->CR2 = tmpcr2;
 8001320:	605a      	str	r2, [r3, #4]
  TIMx->CCR2 = OC_Config->Pulse;
 8001322:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 8001324:	619e      	str	r6, [r3, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8001326:	639a      	str	r2, [r3, #56]	; 0x38
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8001328:	2280      	movs	r2, #128	; 0x80
  TIMx->CCER = tmpccer;
 800132a:	621c      	str	r4, [r3, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 800132c:	699c      	ldr	r4, [r3, #24]
 800132e:	0112      	lsls	r2, r2, #4
 8001330:	4322      	orrs	r2, r4
 8001332:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8001334:	699a      	ldr	r2, [r3, #24]
 8001336:	4c13      	ldr	r4, [pc, #76]	; (8001384 <HAL_TIM_PWM_ConfigChannel+0x23c>)
 8001338:	4022      	ands	r2, r4
 800133a:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 800133c:	690a      	ldr	r2, [r1, #16]
 800133e:	699c      	ldr	r4, [r3, #24]
 8001340:	0212      	lsls	r2, r2, #8
 8001342:	4322      	orrs	r2, r4
 8001344:	619a      	str	r2, [r3, #24]
    break;
 8001346:	e744      	b.n	80011d2 <HAL_TIM_PWM_ConfigChannel+0x8a>
    tmpccer &= ~TIM_CCER_CC2NP;
 8001348:	2580      	movs	r5, #128	; 0x80
 800134a:	43ac      	bics	r4, r5
 800134c:	0025      	movs	r5, r4
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800134e:	68cc      	ldr	r4, [r1, #12]
 8001350:	0124      	lsls	r4, r4, #4
 8001352:	432c      	orrs	r4, r5
    tmpccer &= ~TIM_CCER_CC2NE;
 8001354:	2540      	movs	r5, #64	; 0x40
 8001356:	43ac      	bics	r4, r5
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8001358:	4f11      	ldr	r7, [pc, #68]	; (80013a0 <HAL_TIM_PWM_ConfigChannel+0x258>)
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 800135a:	694d      	ldr	r5, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800135c:	4017      	ands	r7, r2
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 800135e:	698a      	ldr	r2, [r1, #24]
 8001360:	432a      	orrs	r2, r5
 8001362:	0092      	lsls	r2, r2, #2
 8001364:	433a      	orrs	r2, r7
 8001366:	e7db      	b.n	8001320 <HAL_TIM_PWM_ConfigChannel+0x1d8>
 8001368:	ffffefff 	.word	0xffffefff
 800136c:	ffff8cff 	.word	0xffff8cff
 8001370:	ffffdfff 	.word	0xffffdfff
 8001374:	40012c00 	.word	0x40012c00
 8001378:	40014000 	.word	0x40014000
 800137c:	40014400 	.word	0x40014400
 8001380:	40014800 	.word	0x40014800
 8001384:	fffffbff 	.word	0xfffffbff
 8001388:	ffffbfff 	.word	0xffffbfff
 800138c:	fffffcff 	.word	0xfffffcff
 8001390:	fffffeff 	.word	0xfffffeff
 8001394:	fffffdff 	.word	0xfffffdff
 8001398:	fffff7ff 	.word	0xfffff7ff
 800139c:	ffffcfff 	.word	0xffffcfff
 80013a0:	fffff3ff 	.word	0xfffff3ff

080013a4 <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 80013a4:	233c      	movs	r3, #60	; 0x3c
{
 80013a6:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(htim);
 80013a8:	5cc2      	ldrb	r2, [r0, r3]
 80013aa:	2a01      	cmp	r2, #1
 80013ac:	d067      	beq.n	800147e <HAL_TIM_ConfigClockSource+0xda>
 80013ae:	2401      	movs	r4, #1
  htim->State = HAL_TIM_STATE_BUSY;
 80013b0:	2202      	movs	r2, #2
  __HAL_LOCK(htim);
 80013b2:	54c4      	strb	r4, [r0, r3]
  htim->State = HAL_TIM_STATE_BUSY;
 80013b4:	3301      	adds	r3, #1
 80013b6:	54c2      	strb	r2, [r0, r3]
  tmpsmcr = htim->Instance->SMCR;
 80013b8:	6803      	ldr	r3, [r0, #0]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80013ba:	4d5a      	ldr	r5, [pc, #360]	; (8001524 <HAL_TIM_ConfigClockSource+0x180>)
  tmpsmcr = htim->Instance->SMCR;
 80013bc:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80013be:	402a      	ands	r2, r5
  htim->Instance->SMCR = tmpsmcr;
 80013c0:	609a      	str	r2, [r3, #8]
  switch (sClockSourceConfig->ClockSource)
 80013c2:	680a      	ldr	r2, [r1, #0]
 80013c4:	2a40      	cmp	r2, #64	; 0x40
 80013c6:	d100      	bne.n	80013ca <HAL_TIM_ConfigClockSource+0x26>
 80013c8:	e095      	b.n	80014f6 <HAL_TIM_ConfigClockSource+0x152>
 80013ca:	d91d      	bls.n	8001408 <HAL_TIM_ConfigClockSource+0x64>
 80013cc:	2a70      	cmp	r2, #112	; 0x70
 80013ce:	d100      	bne.n	80013d2 <HAL_TIM_ConfigClockSource+0x2e>
 80013d0:	e081      	b.n	80014d6 <HAL_TIM_ConfigClockSource+0x132>
 80013d2:	d92e      	bls.n	8001432 <HAL_TIM_ConfigClockSource+0x8e>
 80013d4:	2480      	movs	r4, #128	; 0x80
 80013d6:	0164      	lsls	r4, r4, #5
 80013d8:	42a2      	cmp	r2, r4
 80013da:	d100      	bne.n	80013de <HAL_TIM_ConfigClockSource+0x3a>
 80013dc:	e076      	b.n	80014cc <HAL_TIM_ConfigClockSource+0x128>
 80013de:	2480      	movs	r4, #128	; 0x80
 80013e0:	01a4      	lsls	r4, r4, #6
 80013e2:	42a2      	cmp	r2, r4
 80013e4:	d11d      	bne.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
  uint32_t tmpsmcr = 0U;

  tmpsmcr = TIMx->SMCR;
 80013e6:	689a      	ldr	r2, [r3, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80013e8:	4c4f      	ldr	r4, [pc, #316]	; (8001528 <HAL_TIM_ConfigClockSource+0x184>)

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80013ea:	684d      	ldr	r5, [r1, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80013ec:	4014      	ands	r4, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80013ee:	688a      	ldr	r2, [r1, #8]
 80013f0:	68c9      	ldr	r1, [r1, #12]
 80013f2:	432a      	orrs	r2, r5
 80013f4:	0209      	lsls	r1, r1, #8
 80013f6:	430a      	orrs	r2, r1
 80013f8:	4322      	orrs	r2, r4

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80013fa:	609a      	str	r2, [r3, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 80013fc:	2280      	movs	r2, #128	; 0x80
 80013fe:	6899      	ldr	r1, [r3, #8]
 8001400:	01d2      	lsls	r2, r2, #7
 8001402:	430a      	orrs	r2, r1
 8001404:	609a      	str	r2, [r3, #8]
    break;
 8001406:	e00c      	b.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
  switch (sClockSourceConfig->ClockSource)
 8001408:	2a10      	cmp	r2, #16
 800140a:	d041      	beq.n	8001490 <HAL_TIM_ConfigClockSource+0xec>
 800140c:	d92e      	bls.n	800146c <HAL_TIM_ConfigClockSource+0xc8>
 800140e:	2a20      	cmp	r2, #32
 8001410:	d037      	beq.n	8001482 <HAL_TIM_ConfigClockSource+0xde>
 8001412:	2a30      	cmp	r2, #48	; 0x30
 8001414:	d105      	bne.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
   tmpsmcr &= ~TIM_SMCR_TS;
 8001416:	2170      	movs	r1, #112	; 0x70
   tmpsmcr = TIMx->SMCR;
 8001418:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 800141a:	438a      	bics	r2, r1
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 800141c:	3939      	subs	r1, #57	; 0x39
 800141e:	430a      	orrs	r2, r1
   TIMx->SMCR = tmpsmcr;
 8001420:	609a      	str	r2, [r3, #8]
  htim->State = HAL_TIM_STATE_READY;
 8001422:	233d      	movs	r3, #61	; 0x3d
 8001424:	2201      	movs	r2, #1
 8001426:	54c2      	strb	r2, [r0, r3]
  __HAL_UNLOCK(htim);
 8001428:	2200      	movs	r2, #0
 800142a:	3b01      	subs	r3, #1
 800142c:	54c2      	strb	r2, [r0, r3]
  return HAL_OK;
 800142e:	2000      	movs	r0, #0
}
 8001430:	bd70      	pop	{r4, r5, r6, pc}
  switch (sClockSourceConfig->ClockSource)
 8001432:	2a50      	cmp	r2, #80	; 0x50
 8001434:	d033      	beq.n	800149e <HAL_TIM_ConfigClockSource+0xfa>
 8001436:	2a60      	cmp	r2, #96	; 0x60
 8001438:	d1f3      	bne.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800143a:	2510      	movs	r5, #16
 800143c:	6a1c      	ldr	r4, [r3, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 800143e:	684a      	ldr	r2, [r1, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8001440:	43ac      	bics	r4, r5
      TIM_TI2_ConfigInputStage(htim->Instance,
 8001442:	68c9      	ldr	r1, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8001444:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8001446:	699d      	ldr	r5, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8001448:	4e38      	ldr	r6, [pc, #224]	; (800152c <HAL_TIM_ConfigClockSource+0x188>)
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800144a:	0309      	lsls	r1, r1, #12
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800144c:	4035      	ands	r5, r6
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800144e:	4329      	orrs	r1, r5
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8001450:	25a0      	movs	r5, #160	; 0xa0
  tmpccer = TIMx->CCER;
 8001452:	6a1c      	ldr	r4, [r3, #32]
  TIMx->CCMR1 = tmpccmr1 ;
 8001454:	6199      	str	r1, [r3, #24]
   tmpsmcr &= ~TIM_SMCR_TS;
 8001456:	2170      	movs	r1, #112	; 0x70
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8001458:	43ac      	bics	r4, r5
  tmpccer |= (TIM_ICPolarity << 4U);
 800145a:	0112      	lsls	r2, r2, #4
 800145c:	4322      	orrs	r2, r4
  TIMx->CCER = tmpccer;
 800145e:	621a      	str	r2, [r3, #32]
   tmpsmcr = TIMx->SMCR;
 8001460:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 8001462:	438a      	bics	r2, r1
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 8001464:	3909      	subs	r1, #9
 8001466:	430a      	orrs	r2, r1
   TIMx->SMCR = tmpsmcr;
 8001468:	609a      	str	r2, [r3, #8]
 800146a:	e7da      	b.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
  switch (sClockSourceConfig->ClockSource)
 800146c:	2a00      	cmp	r2, #0
 800146e:	d1d8      	bne.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
   tmpsmcr &= ~TIM_SMCR_TS;
 8001470:	2170      	movs	r1, #112	; 0x70
   tmpsmcr = TIMx->SMCR;
 8001472:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 8001474:	438a      	bics	r2, r1
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 8001476:	3969      	subs	r1, #105	; 0x69
 8001478:	430a      	orrs	r2, r1
   TIMx->SMCR = tmpsmcr;
 800147a:	609a      	str	r2, [r3, #8]
 800147c:	e7d1      	b.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
  __HAL_LOCK(htim);
 800147e:	2002      	movs	r0, #2
 8001480:	e7d6      	b.n	8001430 <HAL_TIM_ConfigClockSource+0x8c>
   tmpsmcr &= ~TIM_SMCR_TS;
 8001482:	2170      	movs	r1, #112	; 0x70
   tmpsmcr = TIMx->SMCR;
 8001484:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 8001486:	438a      	bics	r2, r1
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 8001488:	3949      	subs	r1, #73	; 0x49
 800148a:	430a      	orrs	r2, r1
   TIMx->SMCR = tmpsmcr;
 800148c:	609a      	str	r2, [r3, #8]
 800148e:	e7c8      	b.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
   tmpsmcr &= ~TIM_SMCR_TS;
 8001490:	2170      	movs	r1, #112	; 0x70
   tmpsmcr = TIMx->SMCR;
 8001492:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 8001494:	438a      	bics	r2, r1
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 8001496:	3959      	subs	r1, #89	; 0x59
 8001498:	430a      	orrs	r2, r1
   TIMx->SMCR = tmpsmcr;
 800149a:	609a      	str	r2, [r3, #8]
 800149c:	e7c1      	b.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800149e:	684d      	ldr	r5, [r1, #4]
 80014a0:	68ca      	ldr	r2, [r1, #12]
  tmpccer = TIMx->CCER;
 80014a2:	6a19      	ldr	r1, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80014a4:	6a1e      	ldr	r6, [r3, #32]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 80014a6:	0112      	lsls	r2, r2, #4
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80014a8:	43a6      	bics	r6, r4
 80014aa:	621e      	str	r6, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 80014ac:	26f0      	movs	r6, #240	; 0xf0
  tmpccmr1 = TIMx->CCMR1;
 80014ae:	699c      	ldr	r4, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 80014b0:	43b4      	bics	r4, r6
  tmpccmr1 |= (TIM_ICFilter << 4U);
 80014b2:	4322      	orrs	r2, r4
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 80014b4:	240a      	movs	r4, #10
 80014b6:	43a1      	bics	r1, r4
  tmpccer |= TIM_ICPolarity;
 80014b8:	4329      	orrs	r1, r5
  TIMx->CCMR1 = tmpccmr1;
 80014ba:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 80014bc:	6219      	str	r1, [r3, #32]
   tmpsmcr &= ~TIM_SMCR_TS;
 80014be:	2170      	movs	r1, #112	; 0x70
   tmpsmcr = TIMx->SMCR;
 80014c0:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 80014c2:	438a      	bics	r2, r1
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 80014c4:	3919      	subs	r1, #25
 80014c6:	430a      	orrs	r2, r1
   TIMx->SMCR = tmpsmcr;
 80014c8:	609a      	str	r2, [r3, #8]
 80014ca:	e7aa      	b.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 80014cc:	2107      	movs	r1, #7
 80014ce:	689a      	ldr	r2, [r3, #8]
 80014d0:	438a      	bics	r2, r1
 80014d2:	609a      	str	r2, [r3, #8]
    break;
 80014d4:	e7a5      	b.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
  tmpsmcr = TIMx->SMCR;
 80014d6:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80014d8:	4c13      	ldr	r4, [pc, #76]	; (8001528 <HAL_TIM_ConfigClockSource+0x184>)
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80014da:	684d      	ldr	r5, [r1, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80014dc:	4014      	ands	r4, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80014de:	688a      	ldr	r2, [r1, #8]
 80014e0:	68c9      	ldr	r1, [r1, #12]
 80014e2:	432a      	orrs	r2, r5
 80014e4:	0209      	lsls	r1, r1, #8
 80014e6:	430a      	orrs	r2, r1
      tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 80014e8:	2177      	movs	r1, #119	; 0x77
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80014ea:	4322      	orrs	r2, r4
  TIMx->SMCR = tmpsmcr;
 80014ec:	609a      	str	r2, [r3, #8]
      tmpsmcr = htim->Instance->SMCR;
 80014ee:	689a      	ldr	r2, [r3, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 80014f0:	430a      	orrs	r2, r1
      htim->Instance->SMCR = tmpsmcr;
 80014f2:	609a      	str	r2, [r3, #8]
    break;
 80014f4:	e795      	b.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
      TIM_TI1_ConfigInputStage(htim->Instance,
 80014f6:	684d      	ldr	r5, [r1, #4]
 80014f8:	68ca      	ldr	r2, [r1, #12]
  tmpccer = TIMx->CCER;
 80014fa:	6a19      	ldr	r1, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80014fc:	6a1e      	ldr	r6, [r3, #32]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 80014fe:	0112      	lsls	r2, r2, #4
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8001500:	43a6      	bics	r6, r4
 8001502:	621e      	str	r6, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8001504:	26f0      	movs	r6, #240	; 0xf0
  tmpccmr1 = TIMx->CCMR1;
 8001506:	699c      	ldr	r4, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8001508:	43b4      	bics	r4, r6
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800150a:	4322      	orrs	r2, r4
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800150c:	240a      	movs	r4, #10
 800150e:	43a1      	bics	r1, r4
  tmpccer |= TIM_ICPolarity;
 8001510:	4329      	orrs	r1, r5
  TIMx->CCMR1 = tmpccmr1;
 8001512:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8001514:	6219      	str	r1, [r3, #32]
   tmpsmcr &= ~TIM_SMCR_TS;
 8001516:	2170      	movs	r1, #112	; 0x70
   tmpsmcr = TIMx->SMCR;
 8001518:	689a      	ldr	r2, [r3, #8]
   tmpsmcr &= ~TIM_SMCR_TS;
 800151a:	438a      	bics	r2, r1
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 800151c:	3929      	subs	r1, #41	; 0x29
 800151e:	430a      	orrs	r2, r1
   TIMx->SMCR = tmpsmcr;
 8001520:	609a      	str	r2, [r3, #8]
 8001522:	e77e      	b.n	8001422 <HAL_TIM_ConfigClockSource+0x7e>
 8001524:	ffff0088 	.word	0xffff0088
 8001528:	ffff00ff 	.word	0xffff00ff
 800152c:	ffff0fff 	.word	0xffff0fff

08001530 <HAL_TIMEx_MasterConfigSynchronization>:
  *         contains the selected trigger output (TRGO) and the Master/Slave 
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
{
 8001530:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  __HAL_LOCK(htim);
 8001532:	243c      	movs	r4, #60	; 0x3c
 8001534:	5d03      	ldrb	r3, [r0, r4]
 8001536:	2b01      	cmp	r3, #1
 8001538:	d019      	beq.n	800156e <HAL_TIMEx_MasterConfigSynchronization+0x3e>

  htim->State = HAL_TIM_STATE_BUSY;
 800153a:	253d      	movs	r5, #61	; 0x3d
 800153c:	2302      	movs	r3, #2

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 800153e:	2670      	movs	r6, #112	; 0x70
  htim->State = HAL_TIM_STATE_BUSY;
 8001540:	5543      	strb	r3, [r0, r5]
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8001542:	6803      	ldr	r3, [r0, #0]
 8001544:	685a      	ldr	r2, [r3, #4]
 8001546:	43b2      	bics	r2, r6
 8001548:	605a      	str	r2, [r3, #4]
  /* Select the TRGO source */
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 800154a:	685a      	ldr	r2, [r3, #4]
 800154c:	680e      	ldr	r6, [r1, #0]

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 800154e:	6849      	ldr	r1, [r1, #4]
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 8001550:	4332      	orrs	r2, r6
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 8001552:	2680      	movs	r6, #128	; 0x80
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 8001554:	605a      	str	r2, [r3, #4]
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 8001556:	689a      	ldr	r2, [r3, #8]
 8001558:	43b2      	bics	r2, r6
 800155a:	609a      	str	r2, [r3, #8]
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 800155c:	689a      	ldr	r2, [r3, #8]
 800155e:	430a      	orrs	r2, r1
 8001560:	609a      	str	r2, [r3, #8]

  htim->State = HAL_TIM_STATE_READY;
 8001562:	2301      	movs	r3, #1
 8001564:	5543      	strb	r3, [r0, r5]

  __HAL_UNLOCK(htim);
 8001566:	2300      	movs	r3, #0
 8001568:	5503      	strb	r3, [r0, r4]

  return HAL_OK;
 800156a:	2000      	movs	r0, #0
}
 800156c:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(htim);
 800156e:	2002      	movs	r0, #2
 8001570:	e7fc      	b.n	800156c <HAL_TIMEx_MasterConfigSynchronization+0x3c>
 8001572:	46c0      	nop			; (mov r8, r8)

08001574 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8001574:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 8001576:	b530      	push	{r4, r5, lr}
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8001578:	07da      	lsls	r2, r3, #31
 800157a:	d506      	bpl.n	800158a <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800157c:	6801      	ldr	r1, [r0, #0]
 800157e:	4c28      	ldr	r4, [pc, #160]	; (8001620 <UART_AdvFeatureConfig+0xac>)
 8001580:	684a      	ldr	r2, [r1, #4]
 8001582:	4022      	ands	r2, r4
 8001584:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8001586:	4322      	orrs	r2, r4
 8001588:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800158a:	079a      	lsls	r2, r3, #30
 800158c:	d506      	bpl.n	800159c <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800158e:	6801      	ldr	r1, [r0, #0]
 8001590:	4c24      	ldr	r4, [pc, #144]	; (8001624 <UART_AdvFeatureConfig+0xb0>)
 8001592:	684a      	ldr	r2, [r1, #4]
 8001594:	4022      	ands	r2, r4
 8001596:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8001598:	4322      	orrs	r2, r4
 800159a:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800159c:	075a      	lsls	r2, r3, #29
 800159e:	d506      	bpl.n	80015ae <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80015a0:	6801      	ldr	r1, [r0, #0]
 80015a2:	4c21      	ldr	r4, [pc, #132]	; (8001628 <UART_AdvFeatureConfig+0xb4>)
 80015a4:	684a      	ldr	r2, [r1, #4]
 80015a6:	4022      	ands	r2, r4
 80015a8:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80015aa:	4322      	orrs	r2, r4
 80015ac:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80015ae:	071a      	lsls	r2, r3, #28
 80015b0:	d506      	bpl.n	80015c0 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80015b2:	6801      	ldr	r1, [r0, #0]
 80015b4:	4c1d      	ldr	r4, [pc, #116]	; (800162c <UART_AdvFeatureConfig+0xb8>)
 80015b6:	684a      	ldr	r2, [r1, #4]
 80015b8:	4022      	ands	r2, r4
 80015ba:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80015bc:	4322      	orrs	r2, r4
 80015be:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80015c0:	06da      	lsls	r2, r3, #27
 80015c2:	d506      	bpl.n	80015d2 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80015c4:	6801      	ldr	r1, [r0, #0]
 80015c6:	4c1a      	ldr	r4, [pc, #104]	; (8001630 <UART_AdvFeatureConfig+0xbc>)
 80015c8:	688a      	ldr	r2, [r1, #8]
 80015ca:	4022      	ands	r2, r4
 80015cc:	6b84      	ldr	r4, [r0, #56]	; 0x38
 80015ce:	4322      	orrs	r2, r4
 80015d0:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80015d2:	069a      	lsls	r2, r3, #26
 80015d4:	d506      	bpl.n	80015e4 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80015d6:	6801      	ldr	r1, [r0, #0]
 80015d8:	4c16      	ldr	r4, [pc, #88]	; (8001634 <UART_AdvFeatureConfig+0xc0>)
 80015da:	688a      	ldr	r2, [r1, #8]
 80015dc:	4022      	ands	r2, r4
 80015de:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 80015e0:	4322      	orrs	r2, r4
 80015e2:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80015e4:	065a      	lsls	r2, r3, #25
 80015e6:	d50a      	bpl.n	80015fe <UART_AdvFeatureConfig+0x8a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80015e8:	6801      	ldr	r1, [r0, #0]
 80015ea:	4d13      	ldr	r5, [pc, #76]	; (8001638 <UART_AdvFeatureConfig+0xc4>)
 80015ec:	684a      	ldr	r2, [r1, #4]
 80015ee:	6c04      	ldr	r4, [r0, #64]	; 0x40
 80015f0:	402a      	ands	r2, r5
 80015f2:	4322      	orrs	r2, r4
 80015f4:	604a      	str	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80015f6:	2280      	movs	r2, #128	; 0x80
 80015f8:	0352      	lsls	r2, r2, #13
 80015fa:	4294      	cmp	r4, r2
 80015fc:	d009      	beq.n	8001612 <UART_AdvFeatureConfig+0x9e>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80015fe:	061b      	lsls	r3, r3, #24
 8001600:	d506      	bpl.n	8001610 <UART_AdvFeatureConfig+0x9c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8001602:	6802      	ldr	r2, [r0, #0]
 8001604:	490d      	ldr	r1, [pc, #52]	; (800163c <UART_AdvFeatureConfig+0xc8>)
 8001606:	6853      	ldr	r3, [r2, #4]
 8001608:	400b      	ands	r3, r1
 800160a:	6c81      	ldr	r1, [r0, #72]	; 0x48
 800160c:	430b      	orrs	r3, r1
 800160e:	6053      	str	r3, [r2, #4]
  }
}
 8001610:	bd30      	pop	{r4, r5, pc}
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8001612:	684a      	ldr	r2, [r1, #4]
 8001614:	4c0a      	ldr	r4, [pc, #40]	; (8001640 <UART_AdvFeatureConfig+0xcc>)
 8001616:	4022      	ands	r2, r4
 8001618:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800161a:	4322      	orrs	r2, r4
 800161c:	604a      	str	r2, [r1, #4]
 800161e:	e7ee      	b.n	80015fe <UART_AdvFeatureConfig+0x8a>
 8001620:	fffdffff 	.word	0xfffdffff
 8001624:	fffeffff 	.word	0xfffeffff
 8001628:	fffbffff 	.word	0xfffbffff
 800162c:	ffff7fff 	.word	0xffff7fff
 8001630:	ffffefff 	.word	0xffffefff
 8001634:	ffffdfff 	.word	0xffffdfff
 8001638:	ffefffff 	.word	0xffefffff
 800163c:	fff7ffff 	.word	0xfff7ffff
 8001640:	ff9fffff 	.word	0xff9fffff

08001644 <HAL_UART_Init>:
{
 8001644:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001646:	46c6      	mov	lr, r8
 8001648:	0004      	movs	r4, r0
 800164a:	b500      	push	{lr}
  if(huart == NULL)
 800164c:	2800      	cmp	r0, #0
 800164e:	d037      	beq.n	80016c0 <HAL_UART_Init+0x7c>
  if(huart->gState == HAL_UART_STATE_RESET)
 8001650:	2369      	movs	r3, #105	; 0x69
 8001652:	5cc3      	ldrb	r3, [r0, r3]
 8001654:	b2db      	uxtb	r3, r3
 8001656:	2b00      	cmp	r3, #0
 8001658:	d036      	beq.n	80016c8 <HAL_UART_Init+0x84>
  huart->gState = HAL_UART_STATE_BUSY;
 800165a:	2369      	movs	r3, #105	; 0x69
 800165c:	2224      	movs	r2, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 800165e:	6825      	ldr	r5, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8001660:	54e2      	strb	r2, [r4, r3]
  __HAL_UART_DISABLE(huart);
 8001662:	682b      	ldr	r3, [r5, #0]
 8001664:	3a23      	subs	r2, #35	; 0x23
 8001666:	4393      	bics	r3, r2
 8001668:	602b      	str	r3, [r5, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800166a:	6920      	ldr	r0, [r4, #16]
 800166c:	68a3      	ldr	r3, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800166e:	682a      	ldr	r2, [r5, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8001670:	4303      	orrs	r3, r0
 8001672:	6960      	ldr	r0, [r4, #20]
 8001674:	69e1      	ldr	r1, [r4, #28]
 8001676:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8001678:	488d      	ldr	r0, [pc, #564]	; (80018b0 <HAL_UART_Init+0x26c>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800167a:	430b      	orrs	r3, r1
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800167c:	4002      	ands	r2, r0
 800167e:	4313      	orrs	r3, r2
 8001680:	602b      	str	r3, [r5, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001682:	686b      	ldr	r3, [r5, #4]
 8001684:	4a8b      	ldr	r2, [pc, #556]	; (80018b4 <HAL_UART_Init+0x270>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8001686:	6a20      	ldr	r0, [r4, #32]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001688:	4013      	ands	r3, r2
 800168a:	68e2      	ldr	r2, [r4, #12]
 800168c:	4313      	orrs	r3, r2
 800168e:	606b      	str	r3, [r5, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8001690:	69a3      	ldr	r3, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8001692:	68aa      	ldr	r2, [r5, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8001694:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8001696:	4888      	ldr	r0, [pc, #544]	; (80018b8 <HAL_UART_Init+0x274>)
 8001698:	4002      	ands	r2, r0
 800169a:	4313      	orrs	r3, r2
 800169c:	60ab      	str	r3, [r5, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 800169e:	4b87      	ldr	r3, [pc, #540]	; (80018bc <HAL_UART_Init+0x278>)
 80016a0:	429d      	cmp	r5, r3
 80016a2:	d04f      	beq.n	8001744 <HAL_UART_Init+0x100>
 80016a4:	4b86      	ldr	r3, [pc, #536]	; (80018c0 <HAL_UART_Init+0x27c>)
 80016a6:	429d      	cmp	r5, r3
 80016a8:	d063      	beq.n	8001772 <HAL_UART_Init+0x12e>
 80016aa:	4b86      	ldr	r3, [pc, #536]	; (80018c4 <HAL_UART_Init+0x280>)
 80016ac:	429d      	cmp	r5, r3
 80016ae:	d012      	beq.n	80016d6 <HAL_UART_Init+0x92>
 80016b0:	4b85      	ldr	r3, [pc, #532]	; (80018c8 <HAL_UART_Init+0x284>)
 80016b2:	429d      	cmp	r5, r3
 80016b4:	d00f      	beq.n	80016d6 <HAL_UART_Init+0x92>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80016b6:	2380      	movs	r3, #128	; 0x80
 80016b8:	021b      	lsls	r3, r3, #8
 80016ba:	4299      	cmp	r1, r3
 80016bc:	d100      	bne.n	80016c0 <HAL_UART_Init+0x7c>
 80016be:	e0e5      	b.n	800188c <HAL_UART_Init+0x248>
    return HAL_ERROR;
 80016c0:	2001      	movs	r0, #1
}
 80016c2:	bc04      	pop	{r2}
 80016c4:	4690      	mov	r8, r2
 80016c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    huart->Lock = HAL_UNLOCKED;
 80016c8:	2268      	movs	r2, #104	; 0x68
 80016ca:	5483      	strb	r3, [r0, r2]
    HAL_UART_MspInit(huart);
 80016cc:	f000 fb4a 	bl	8001d64 <HAL_UART_MspInit>
 80016d0:	e7c3      	b.n	800165a <HAL_UART_Init+0x16>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80016d2:	2b00      	cmp	r3, #0
 80016d4:	d1ef      	bne.n	80016b6 <HAL_UART_Init+0x72>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80016d6:	2380      	movs	r3, #128	; 0x80
 80016d8:	021b      	lsls	r3, r3, #8
 80016da:	4299      	cmp	r1, r3
 80016dc:	d100      	bne.n	80016e0 <HAL_UART_Init+0x9c>
 80016de:	e0c4      	b.n	800186a <HAL_UART_Init+0x226>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80016e0:	f7ff fb12 	bl	8000d08 <HAL_RCC_GetPCLK1Freq>
 80016e4:	6863      	ldr	r3, [r4, #4]
 80016e6:	6825      	ldr	r5, [r4, #0]
 80016e8:	085b      	lsrs	r3, r3, #1
 80016ea:	1818      	adds	r0, r3, r0
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 80016ec:	6861      	ldr	r1, [r4, #4]
 80016ee:	f7fe fd0b 	bl	8000108 <__udivsi3>
 80016f2:	0400      	lsls	r0, r0, #16
 80016f4:	0c00      	lsrs	r0, r0, #16
 80016f6:	60e8      	str	r0, [r5, #12]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80016f8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80016fa:	2b00      	cmp	r3, #0
 80016fc:	d000      	beq.n	8001700 <HAL_UART_Init+0xbc>
 80016fe:	e082      	b.n	8001806 <HAL_UART_Init+0x1c2>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001700:	686b      	ldr	r3, [r5, #4]
 8001702:	4a72      	ldr	r2, [pc, #456]	; (80018cc <HAL_UART_Init+0x288>)
 8001704:	4013      	ands	r3, r2
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8001706:	222a      	movs	r2, #42	; 0x2a
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001708:	606b      	str	r3, [r5, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800170a:	68ab      	ldr	r3, [r5, #8]
 800170c:	4393      	bics	r3, r2
 800170e:	60ab      	str	r3, [r5, #8]
  __HAL_UART_ENABLE(huart);
 8001710:	682b      	ldr	r3, [r5, #0]
 8001712:	3a29      	subs	r2, #41	; 0x29
 8001714:	4313      	orrs	r3, r2
 8001716:	602b      	str	r3, [r5, #0]
#if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
  uint32_t tickstart = 0U;
#endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001718:	2300      	movs	r3, #0
 800171a:	66e3      	str	r3, [r4, #108]	; 0x6c

#if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 800171c:	f7fe fdaa 	bl	8000274 <HAL_GetTick>

  /* TEACK and REACK bits in ISR are checked only when available (not available on all F0 devices).
     Bits are defined for some specific devices, and are available only for UART instances supporting WakeUp from Stop Mode feature. 
  */
  if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
 8001720:	6823      	ldr	r3, [r4, #0]
 8001722:	4a66      	ldr	r2, [pc, #408]	; (80018bc <HAL_UART_Init+0x278>)
  tickstart = HAL_GetTick();
 8001724:	0006      	movs	r6, r0
  if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
 8001726:	4293      	cmp	r3, r2
 8001728:	d048      	beq.n	80017bc <HAL_UART_Init+0x178>
 800172a:	4a65      	ldr	r2, [pc, #404]	; (80018c0 <HAL_UART_Init+0x27c>)
 800172c:	4293      	cmp	r3, r2
 800172e:	d045      	beq.n	80017bc <HAL_UART_Init+0x178>
    }
  }
#endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */

  /* Initialize the UART State */
  huart->gState  = HAL_UART_STATE_READY;
 8001730:	2320      	movs	r3, #32
 8001732:	2269      	movs	r2, #105	; 0x69
 8001734:	54a3      	strb	r3, [r4, r2]
  huart->RxState = HAL_UART_STATE_READY;
 8001736:	3201      	adds	r2, #1
 8001738:	54a3      	strb	r3, [r4, r2]

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800173a:	2200      	movs	r2, #0
 800173c:	3348      	adds	r3, #72	; 0x48
 800173e:	54e2      	strb	r2, [r4, r3]

  return HAL_OK;
 8001740:	2000      	movs	r0, #0
 8001742:	e7be      	b.n	80016c2 <HAL_UART_Init+0x7e>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8001744:	4b62      	ldr	r3, [pc, #392]	; (80018d0 <HAL_UART_Init+0x28c>)
 8001746:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001748:	2303      	movs	r3, #3
 800174a:	4013      	ands	r3, r2
 800174c:	4a61      	ldr	r2, [pc, #388]	; (80018d4 <HAL_UART_Init+0x290>)
 800174e:	5cd3      	ldrb	r3, [r2, r3]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001750:	2280      	movs	r2, #128	; 0x80
 8001752:	0212      	lsls	r2, r2, #8
 8001754:	4291      	cmp	r1, r2
 8001756:	d06f      	beq.n	8001838 <HAL_UART_Init+0x1f4>
    switch (clocksource)
 8001758:	2b02      	cmp	r3, #2
 800175a:	d059      	beq.n	8001810 <HAL_UART_Init+0x1cc>
 800175c:	d800      	bhi.n	8001760 <HAL_UART_Init+0x11c>
 800175e:	e0a2      	b.n	80018a6 <HAL_UART_Init+0x262>
 8001760:	2b04      	cmp	r3, #4
 8001762:	d024      	beq.n	80017ae <HAL_UART_Init+0x16a>
 8001764:	2b08      	cmp	r3, #8
 8001766:	d1ab      	bne.n	80016c0 <HAL_UART_Init+0x7c>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8001768:	6863      	ldr	r3, [r4, #4]
 800176a:	0858      	lsrs	r0, r3, #1
 800176c:	2380      	movs	r3, #128	; 0x80
 800176e:	021b      	lsls	r3, r3, #8
 8001770:	e051      	b.n	8001816 <HAL_UART_Init+0x1d2>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8001772:	20c0      	movs	r0, #192	; 0xc0
 8001774:	2280      	movs	r2, #128	; 0x80
 8001776:	4b56      	ldr	r3, [pc, #344]	; (80018d0 <HAL_UART_Init+0x28c>)
 8001778:	0280      	lsls	r0, r0, #10
 800177a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800177c:	0252      	lsls	r2, r2, #9
 800177e:	4003      	ands	r3, r0
 8001780:	4293      	cmp	r3, r2
 8001782:	d010      	beq.n	80017a6 <HAL_UART_Init+0x162>
 8001784:	d9a5      	bls.n	80016d2 <HAL_UART_Init+0x8e>
 8001786:	2280      	movs	r2, #128	; 0x80
 8001788:	0292      	lsls	r2, r2, #10
 800178a:	4293      	cmp	r3, r2
 800178c:	d100      	bne.n	8001790 <HAL_UART_Init+0x14c>
 800178e:	e081      	b.n	8001894 <HAL_UART_Init+0x250>
 8001790:	4283      	cmp	r3, r0
 8001792:	d000      	beq.n	8001796 <HAL_UART_Init+0x152>
 8001794:	e78f      	b.n	80016b6 <HAL_UART_Init+0x72>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001796:	2380      	movs	r3, #128	; 0x80
 8001798:	021b      	lsls	r3, r3, #8
 800179a:	4299      	cmp	r1, r3
 800179c:	d138      	bne.n	8001810 <HAL_UART_Init+0x1cc>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 800179e:	6863      	ldr	r3, [r4, #4]
 80017a0:	0858      	lsrs	r0, r3, #1
 80017a2:	4b4d      	ldr	r3, [pc, #308]	; (80018d8 <HAL_UART_Init+0x294>)
 80017a4:	e053      	b.n	800184e <HAL_UART_Init+0x20a>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80017a6:	2380      	movs	r3, #128	; 0x80
 80017a8:	021b      	lsls	r3, r3, #8
 80017aa:	4299      	cmp	r1, r3
 80017ac:	d078      	beq.n	80018a0 <HAL_UART_Init+0x25c>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80017ae:	f7ff fa5f 	bl	8000c70 <HAL_RCC_GetSysClockFreq>
 80017b2:	6863      	ldr	r3, [r4, #4]
 80017b4:	6825      	ldr	r5, [r4, #0]
 80017b6:	085b      	lsrs	r3, r3, #1
 80017b8:	1818      	adds	r0, r3, r0
 80017ba:	e797      	b.n	80016ec <HAL_UART_Init+0xa8>
    if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80017bc:	681a      	ldr	r2, [r3, #0]
 80017be:	0712      	lsls	r2, r2, #28
 80017c0:	d42c      	bmi.n	800181c <HAL_UART_Init+0x1d8>
    if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80017c2:	681a      	ldr	r2, [r3, #0]
 80017c4:	0752      	lsls	r2, r2, #29
 80017c6:	d5b3      	bpl.n	8001730 <HAL_UART_Init+0xec>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80017c8:	4a44      	ldr	r2, [pc, #272]	; (80018dc <HAL_UART_Init+0x298>)
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80017ca:	2780      	movs	r7, #128	; 0x80
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80017cc:	4690      	mov	r8, r2
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80017ce:	03ff      	lsls	r7, r7, #15
 80017d0:	69dd      	ldr	r5, [r3, #28]
 80017d2:	403d      	ands	r5, r7
 80017d4:	d1ac      	bne.n	8001730 <HAL_UART_Init+0xec>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80017d6:	f7fe fd4d 	bl	8000274 <HAL_GetTick>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80017da:	6823      	ldr	r3, [r4, #0]
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80017dc:	1b80      	subs	r0, r0, r6
 80017de:	4540      	cmp	r0, r8
 80017e0:	d9f6      	bls.n	80017d0 <HAL_UART_Init+0x18c>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80017e2:	681a      	ldr	r2, [r3, #0]
 80017e4:	493e      	ldr	r1, [pc, #248]	; (80018e0 <HAL_UART_Init+0x29c>)
        return HAL_TIMEOUT;
 80017e6:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80017e8:	400a      	ands	r2, r1
 80017ea:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80017ec:	689a      	ldr	r2, [r3, #8]
 80017ee:	31a3      	adds	r1, #163	; 0xa3
 80017f0:	31ff      	adds	r1, #255	; 0xff
 80017f2:	438a      	bics	r2, r1
 80017f4:	609a      	str	r2, [r3, #8]

        huart->gState  = HAL_UART_STATE_READY;
 80017f6:	2320      	movs	r3, #32
 80017f8:	2269      	movs	r2, #105	; 0x69
 80017fa:	54a3      	strb	r3, [r4, r2]
        huart->RxState = HAL_UART_STATE_READY;
 80017fc:	3201      	adds	r2, #1
 80017fe:	54a3      	strb	r3, [r4, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 8001800:	3348      	adds	r3, #72	; 0x48
 8001802:	54e5      	strb	r5, [r4, r3]
 8001804:	e75d      	b.n	80016c2 <HAL_UART_Init+0x7e>
    UART_AdvFeatureConfig(huart);
 8001806:	0020      	movs	r0, r4
 8001808:	f7ff feb4 	bl	8001574 <UART_AdvFeatureConfig>
 800180c:	6825      	ldr	r5, [r4, #0]
 800180e:	e777      	b.n	8001700 <HAL_UART_Init+0xbc>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8001810:	6863      	ldr	r3, [r4, #4]
 8001812:	0858      	lsrs	r0, r3, #1
 8001814:	4b33      	ldr	r3, [pc, #204]	; (80018e4 <HAL_UART_Init+0x2a0>)
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8001816:	469c      	mov	ip, r3
 8001818:	4460      	add	r0, ip
 800181a:	e767      	b.n	80016ec <HAL_UART_Init+0xa8>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 800181c:	4a2f      	ldr	r2, [pc, #188]	; (80018dc <HAL_UART_Init+0x298>)
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800181e:	2780      	movs	r7, #128	; 0x80
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8001820:	4690      	mov	r8, r2
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8001822:	03bf      	lsls	r7, r7, #14
 8001824:	69dd      	ldr	r5, [r3, #28]
 8001826:	403d      	ands	r5, r7
 8001828:	d1cb      	bne.n	80017c2 <HAL_UART_Init+0x17e>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 800182a:	f7fe fd23 	bl	8000274 <HAL_GetTick>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800182e:	6823      	ldr	r3, [r4, #0]
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8001830:	1b80      	subs	r0, r0, r6
 8001832:	4540      	cmp	r0, r8
 8001834:	d9f6      	bls.n	8001824 <HAL_UART_Init+0x1e0>
 8001836:	e7d4      	b.n	80017e2 <HAL_UART_Init+0x19e>
    switch (clocksource)
 8001838:	2b02      	cmp	r3, #2
 800183a:	d0b0      	beq.n	800179e <HAL_UART_Init+0x15a>
 800183c:	d913      	bls.n	8001866 <HAL_UART_Init+0x222>
 800183e:	2b04      	cmp	r3, #4
 8001840:	d02e      	beq.n	80018a0 <HAL_UART_Init+0x25c>
 8001842:	2b08      	cmp	r3, #8
 8001844:	d122      	bne.n	800188c <HAL_UART_Init+0x248>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8001846:	6863      	ldr	r3, [r4, #4]
 8001848:	0858      	lsrs	r0, r3, #1
 800184a:	2380      	movs	r3, #128	; 0x80
 800184c:	025b      	lsls	r3, r3, #9
 800184e:	469c      	mov	ip, r3
 8001850:	6861      	ldr	r1, [r4, #4]
 8001852:	4460      	add	r0, ip
 8001854:	f7fe fc58 	bl	8000108 <__udivsi3>
    brrtemp = usartdiv & 0xFFF0U;
 8001858:	4b23      	ldr	r3, [pc, #140]	; (80018e8 <HAL_UART_Init+0x2a4>)
 800185a:	4003      	ands	r3, r0
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800185c:	0700      	lsls	r0, r0, #28
 800185e:	0f40      	lsrs	r0, r0, #29
    huart->Instance->BRR = brrtemp;
 8001860:	4318      	orrs	r0, r3
 8001862:	60e8      	str	r0, [r5, #12]
 8001864:	e748      	b.n	80016f8 <HAL_UART_Init+0xb4>
    switch (clocksource)
 8001866:	2b00      	cmp	r3, #0
 8001868:	d110      	bne.n	800188c <HAL_UART_Init+0x248>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800186a:	f7ff fa4d 	bl	8000d08 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800186e:	6863      	ldr	r3, [r4, #4]
 8001870:	0040      	lsls	r0, r0, #1
 8001872:	085b      	lsrs	r3, r3, #1
 8001874:	18c0      	adds	r0, r0, r3
 8001876:	6861      	ldr	r1, [r4, #4]
 8001878:	f7fe fc46 	bl	8000108 <__udivsi3>
    brrtemp = usartdiv & 0xFFF0U;
 800187c:	4b1a      	ldr	r3, [pc, #104]	; (80018e8 <HAL_UART_Init+0x2a4>)
    huart->Instance->BRR = brrtemp;
 800187e:	6825      	ldr	r5, [r4, #0]
    brrtemp = usartdiv & 0xFFF0U;
 8001880:	4003      	ands	r3, r0
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8001882:	0700      	lsls	r0, r0, #28
 8001884:	0f40      	lsrs	r0, r0, #29
    huart->Instance->BRR = brrtemp;
 8001886:	4318      	orrs	r0, r3
 8001888:	60e8      	str	r0, [r5, #12]
 800188a:	e735      	b.n	80016f8 <HAL_UART_Init+0xb4>
 800188c:	2300      	movs	r3, #0
    return HAL_ERROR;
 800188e:	2001      	movs	r0, #1
    huart->Instance->BRR = brrtemp;
 8001890:	60eb      	str	r3, [r5, #12]
 8001892:	e716      	b.n	80016c2 <HAL_UART_Init+0x7e>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001894:	2380      	movs	r3, #128	; 0x80
 8001896:	021b      	lsls	r3, r3, #8
 8001898:	4299      	cmp	r1, r3
 800189a:	d000      	beq.n	800189e <HAL_UART_Init+0x25a>
 800189c:	e764      	b.n	8001768 <HAL_UART_Init+0x124>
 800189e:	e7d2      	b.n	8001846 <HAL_UART_Init+0x202>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80018a0:	f7ff f9e6 	bl	8000c70 <HAL_RCC_GetSysClockFreq>
 80018a4:	e7e3      	b.n	800186e <HAL_UART_Init+0x22a>
    switch (clocksource)
 80018a6:	2b00      	cmp	r3, #0
 80018a8:	d000      	beq.n	80018ac <HAL_UART_Init+0x268>
 80018aa:	e709      	b.n	80016c0 <HAL_UART_Init+0x7c>
 80018ac:	e718      	b.n	80016e0 <HAL_UART_Init+0x9c>
 80018ae:	46c0      	nop			; (mov r8, r8)
 80018b0:	efff69f3 	.word	0xefff69f3
 80018b4:	ffffcfff 	.word	0xffffcfff
 80018b8:	fffff4ff 	.word	0xfffff4ff
 80018bc:	40013800 	.word	0x40013800
 80018c0:	40004400 	.word	0x40004400
 80018c4:	40004800 	.word	0x40004800
 80018c8:	40004c00 	.word	0x40004c00
 80018cc:	ffffb7ff 	.word	0xffffb7ff
 80018d0:	40021000 	.word	0x40021000
 80018d4:	08001f20 	.word	0x08001f20
 80018d8:	00f42400 	.word	0x00f42400
 80018dc:	01ffffff 	.word	0x01ffffff
 80018e0:	fffffe5f 	.word	0xfffffe5f
 80018e4:	007a1200 	.word	0x007a1200
 80018e8:	0000fff0 	.word	0x0000fff0

080018ec <_Z18SystemClock_Configv>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80018ec:	b510      	push	{r4, lr}
 80018ee:	b098      	sub	sp, #96	; 0x60
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80018f0:	2230      	movs	r2, #48	; 0x30
 80018f2:	2100      	movs	r1, #0
 80018f4:	a80c      	add	r0, sp, #48	; 0x30
 80018f6:	f000 faef 	bl	8001ed8 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80018fa:	2210      	movs	r2, #16
 80018fc:	2100      	movs	r1, #0
 80018fe:	4668      	mov	r0, sp
 8001900:	f000 faea 	bl	8001ed8 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8001904:	221c      	movs	r2, #28
 8001906:	2100      	movs	r1, #0
 8001908:	a804      	add	r0, sp, #16
 800190a:	f000 fae5 	bl	8001ed8 <memset>

  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
 800190e:	2320      	movs	r3, #32
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001910:	a80b      	add	r0, sp, #44	; 0x2c
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
 8001912:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 8001914:	3b1f      	subs	r3, #31
 8001916:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001918:	f7fe fe0e 	bl	8000538 <HAL_RCC_OscConfig>
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800191c:	2307      	movs	r3, #7
                              |RCC_CLOCKTYPE_PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800191e:	2400      	movs	r4, #0
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8001920:	9300      	str	r3, [sp, #0]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8001922:	2101      	movs	r1, #1
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
 8001924:	3b04      	subs	r3, #4
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8001926:	4668      	mov	r0, sp
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
 8001928:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800192a:	9402      	str	r4, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800192c:	9403      	str	r4, [sp, #12]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 800192e:	f7ff f89b 	bl	8000a68 <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8001932:	2302      	movs	r3, #2
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8001934:	a804      	add	r0, sp, #16
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8001936:	9304      	str	r3, [sp, #16]
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 8001938:	9407      	str	r4, [sp, #28]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800193a:	f7ff f9f5 	bl	8000d28 <HAL_RCCEx_PeriphCLKConfig>
  {
    Error_Handler();
  }
}
 800193e:	b018      	add	sp, #96	; 0x60
 8001940:	bd10      	pop	{r4, pc}
 8001942:	46c0      	nop			; (mov r8, r8)

08001944 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv>:
		this->lastLedChanged = node_number;
	}
}

template<uint16_t NUM_LEDS>
void LED_STRIP_WS2811<NUM_LEDS>::display()
 8001944:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001946:	b672      	cpsid	i
{
	//Disable interrupts
	__disable_irq();
	//Write the changed leds
	if(lastLedChanged < NUM_LEDS)
 8001948:	2300      	movs	r3, #0
 800194a:	5ec2      	ldrsh	r2, [r0, r3]
	{
		//Set first CC value
//		this->tim_ptr->Instance->SR &= ~TIM_SR_UIF;
//		this->tim_ptr->Instance->CCR1 = ((leds[0].blue & 0x80) ? T1H : T0H);
//		this->tim_ptr->Instance->EGR = TIM_EGR_UG;
		this->tim_ptr->Instance->CCR1 = 0;
 800194c:	6843      	ldr	r3, [r0, #4]
 800194e:	681b      	ldr	r3, [r3, #0]
	if(lastLedChanged < NUM_LEDS)
 8001950:	2a31      	cmp	r2, #49	; 0x31
 8001952:	dc41      	bgt.n	80019d8 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x94>
		this->tim_ptr->Instance->CCR1 = 0;
 8001954:	2100      	movs	r1, #0
		this->tim_ptr->Instance->CR1 |= TIM_CR1_CEN;
 8001956:	2401      	movs	r4, #1
		this->tim_ptr->Instance->CCR1 = 0;
 8001958:	6359      	str	r1, [r3, #52]	; 0x34
		this->tim_ptr->Instance->CR1 |= TIM_CR1_CEN;
 800195a:	6819      	ldr	r1, [r3, #0]
 800195c:	4321      	orrs	r1, r4
 800195e:	6019      	str	r1, [r3, #0]
		for(int16_t i = 0; i <= lastLedChanged; i++)
 8001960:	2a00      	cmp	r2, #0
 8001962:	db39      	blt.n	80019d8 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x94>
 8001964:	0057      	lsls	r7, r2, #1
 8001966:	18ba      	adds	r2, r7, r2
 8001968:	0007      	movs	r7, r0
 800196a:	370b      	adds	r7, #11
 800196c:	46bc      	mov	ip, r7
 800196e:	0006      	movs	r6, r0
 8001970:	4494      	add	ip, r2
		this->tim_ptr->Instance->CCR1 = T1H;
 8001972:	250b      	movs	r5, #11
		this->outputBit(byte & (1 << (7-i)));
 8001974:	2201      	movs	r2, #1
 8001976:	3608      	adds	r6, #8
	this->outputByte(node.blue);
 8001978:	2407      	movs	r4, #7
 800197a:	78b7      	ldrb	r7, [r6, #2]
		this->outputBit(byte & (1 << (7-i)));
 800197c:	0039      	movs	r1, r7
 800197e:	4121      	asrs	r1, r4
	if(high_nlow)
 8001980:	420a      	tst	r2, r1
 8001982:	d039      	beq.n	80019f8 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0xb4>
		this->tim_ptr->Instance->CCR1 = T1H;
 8001984:	635d      	str	r5, [r3, #52]	; 0x34
	while(this->tim_ptr->Instance->CR1 & TIM_CR1_CEN);
 8001986:	6819      	ldr	r1, [r3, #0]
 8001988:	420a      	tst	r2, r1
 800198a:	d1fc      	bne.n	8001986 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x42>
	this->tim_ptr->Instance->CR1 |= TIM_CR1_CEN;
 800198c:	6819      	ldr	r1, [r3, #0]
 800198e:	4311      	orrs	r1, r2
 8001990:	6019      	str	r1, [r3, #0]
	for(uint8_t i = 0; i < 8; i++)
 8001992:	3c01      	subs	r4, #1
 8001994:	d2f2      	bcs.n	800197c <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x38>
	this->outputByte(node.red);
 8001996:	2407      	movs	r4, #7
 8001998:	7837      	ldrb	r7, [r6, #0]
		this->outputBit(byte & (1 << (7-i)));
 800199a:	0039      	movs	r1, r7
 800199c:	4121      	asrs	r1, r4
	if(high_nlow)
 800199e:	420a      	tst	r2, r1
 80019a0:	d028      	beq.n	80019f4 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0xb0>
		this->tim_ptr->Instance->CCR1 = T1H;
 80019a2:	635d      	str	r5, [r3, #52]	; 0x34
	while(this->tim_ptr->Instance->CR1 & TIM_CR1_CEN);
 80019a4:	6819      	ldr	r1, [r3, #0]
 80019a6:	420a      	tst	r2, r1
 80019a8:	d1fc      	bne.n	80019a4 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x60>
	this->tim_ptr->Instance->CR1 |= TIM_CR1_CEN;
 80019aa:	6819      	ldr	r1, [r3, #0]
 80019ac:	4311      	orrs	r1, r2
 80019ae:	6019      	str	r1, [r3, #0]
	for(uint8_t i = 0; i < 8; i++)
 80019b0:	3c01      	subs	r4, #1
 80019b2:	d2f2      	bcs.n	800199a <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x56>
	this->outputByte(node.green);
 80019b4:	2407      	movs	r4, #7
 80019b6:	7877      	ldrb	r7, [r6, #1]
		this->outputBit(byte & (1 << (7-i)));
 80019b8:	0039      	movs	r1, r7
 80019ba:	4121      	asrs	r1, r4
	if(high_nlow)
 80019bc:	420a      	tst	r2, r1
 80019be:	d017      	beq.n	80019f0 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0xac>
		this->tim_ptr->Instance->CCR1 = T1H;
 80019c0:	635d      	str	r5, [r3, #52]	; 0x34
	while(this->tim_ptr->Instance->CR1 & TIM_CR1_CEN);
 80019c2:	6819      	ldr	r1, [r3, #0]
 80019c4:	420a      	tst	r2, r1
 80019c6:	d1fc      	bne.n	80019c2 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x7e>
	this->tim_ptr->Instance->CR1 |= TIM_CR1_CEN;
 80019c8:	6819      	ldr	r1, [r3, #0]
 80019ca:	4311      	orrs	r1, r2
 80019cc:	6019      	str	r1, [r3, #0]
	for(uint8_t i = 0; i < 8; i++)
 80019ce:	3c01      	subs	r4, #1
 80019d0:	d2f2      	bcs.n	80019b8 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x74>
 80019d2:	3603      	adds	r6, #3
		for(int16_t i = 0; i <= lastLedChanged; i++)
 80019d4:	45b4      	cmp	ip, r6
 80019d6:	d1cf      	bne.n	8001978 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x34>
		{
			this->outputLedNode(leds[i]);
		}
	}
	this->tim_ptr->Instance->CCR1 = 0;
 80019d8:	2200      	movs	r2, #0
 80019da:	635a      	str	r2, [r3, #52]	; 0x34
	this->tim_ptr->Instance->EGR = TIM_EGR_UG;
 80019dc:	3201      	adds	r2, #1
 80019de:	615a      	str	r2, [r3, #20]
	this->lastLedChanged = -1;
 80019e0:	2301      	movs	r3, #1
 80019e2:	425b      	negs	r3, r3
 80019e4:	8003      	strh	r3, [r0, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 80019e6:	b662      	cpsie	i
	//Reenable interrupts
	__enable_irq();
	HAL_Delay(1);
 80019e8:	2001      	movs	r0, #1
 80019ea:	f7fe fc49 	bl	8000280 <HAL_Delay>
}
 80019ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		this->tim_ptr->Instance->CCR1 = T0H;
 80019f0:	635a      	str	r2, [r3, #52]	; 0x34
 80019f2:	e7e6      	b.n	80019c2 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x7e>
 80019f4:	635a      	str	r2, [r3, #52]	; 0x34
 80019f6:	e7d5      	b.n	80019a4 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x60>
 80019f8:	635a      	str	r2, [r3, #52]	; 0x34
 80019fa:	e7c4      	b.n	8001986 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv+0x42>

080019fc <main>:
{
 80019fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80019fe:	46d6      	mov	lr, sl
 8001a00:	464f      	mov	r7, r9
 8001a02:	4646      	mov	r6, r8
 8001a04:	b5c0      	push	{r6, r7, lr}
 8001a06:	b0b2      	sub	sp, #200	; 0xc8
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001a08:	ad0a      	add	r5, sp, #40	; 0x28
  HAL_Init();
 8001a0a:	f7fe fc1b 	bl	8000244 <HAL_Init>
  SystemClock_Config();
 8001a0e:	f7ff ff6d 	bl	80018ec <_Z18SystemClock_Configv>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001a12:	2214      	movs	r2, #20
 8001a14:	2100      	movs	r1, #0
 8001a16:	0028      	movs	r0, r5
 8001a18:	f000 fa5e 	bl	8001ed8 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001a1c:	2080      	movs	r0, #128	; 0x80
 8001a1e:	4b9b      	ldr	r3, [pc, #620]	; (8001c8c <main+0x290>)
 8001a20:	0300      	lsls	r0, r0, #12
 8001a22:	6959      	ldr	r1, [r3, #20]
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001a24:	2400      	movs	r4, #0
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001a26:	4301      	orrs	r1, r0
 8001a28:	6159      	str	r1, [r3, #20]
 8001a2a:	695a      	ldr	r2, [r3, #20]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : LD2_Pin */
  GPIO_InitStruct.Pin = LD2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001a2c:	2701      	movs	r7, #1
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001a2e:	4002      	ands	r2, r0
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8001a30:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001a32:	9201      	str	r2, [sp, #4]
 8001a34:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8001a36:	6959      	ldr	r1, [r3, #20]
 8001a38:	03c0      	lsls	r0, r0, #15
 8001a3a:	4301      	orrs	r1, r0
 8001a3c:	6159      	str	r1, [r3, #20]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a3e:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8001a40:	695a      	ldr	r2, [r3, #20]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a42:	0289      	lsls	r1, r1, #10
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8001a44:	4002      	ands	r2, r0
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 8001a46:	2090      	movs	r0, #144	; 0x90
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8001a48:	9202      	str	r2, [sp, #8]
 8001a4a:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a4c:	695a      	ldr	r2, [r3, #20]
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 8001a4e:	05c0      	lsls	r0, r0, #23
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a50:	430a      	orrs	r2, r1
 8001a52:	615a      	str	r2, [r3, #20]
 8001a54:	695b      	ldr	r3, [r3, #20]
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 8001a56:	2200      	movs	r2, #0
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a58:	400b      	ands	r3, r1
 8001a5a:	9303      	str	r3, [sp, #12]
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 8001a5c:	2120      	movs	r1, #32
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001a5e:	9b03      	ldr	r3, [sp, #12]
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 8001a60:	f7fe fd64 	bl	800052c <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = B1_Pin;
 8001a64:	2380      	movs	r3, #128	; 0x80
 8001a66:	019b      	lsls	r3, r3, #6
 8001a68:	930a      	str	r3, [sp, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8001a6a:	4b89      	ldr	r3, [pc, #548]	; (8001c90 <main+0x294>)
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8001a6c:	0029      	movs	r1, r5
 8001a6e:	4889      	ldr	r0, [pc, #548]	; (8001c94 <main+0x298>)
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8001a70:	606b      	str	r3, [r5, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001a72:	60ac      	str	r4, [r5, #8]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8001a74:	f7fe fc5e 	bl	8000334 <HAL_GPIO_Init>
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
 8001a78:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = LD2_Pin;
 8001a7a:	2320      	movs	r3, #32
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
 8001a7c:	0029      	movs	r1, r5
 8001a7e:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = LD2_Pin;
 8001a80:	930a      	str	r3, [sp, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001a82:	606f      	str	r7, [r5, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001a84:	60ac      	str	r4, [r5, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001a86:	60ec      	str	r4, [r5, #12]
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
 8001a88:	f7fe fc54 	bl	8000334 <HAL_GPIO_Init>
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8001a8c:	2210      	movs	r2, #16
 8001a8e:	2100      	movs	r1, #0
 8001a90:	a806      	add	r0, sp, #24
 8001a92:	f000 fa21 	bl	8001ed8 <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8001a96:	2208      	movs	r2, #8
 8001a98:	2100      	movs	r1, #0
 8001a9a:	a804      	add	r0, sp, #16
 8001a9c:	f000 fa1c 	bl	8001ed8 <memset>
  TIM_OC_InitTypeDef sConfigOC = {0};
 8001aa0:	221c      	movs	r2, #28
 8001aa2:	2100      	movs	r1, #0
 8001aa4:	0028      	movs	r0, r5
 8001aa6:	f000 fa17 	bl	8001ed8 <memset>
  htim3.Instance = TIM3;
 8001aaa:	4e7b      	ldr	r6, [pc, #492]	; (8001c98 <main+0x29c>)
 8001aac:	4b7b      	ldr	r3, [pc, #492]	; (8001c9c <main+0x2a0>)
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8001aae:	0030      	movs	r0, r6
  htim3.Instance = TIM3;
 8001ab0:	6033      	str	r3, [r6, #0]
  htim3.Init.Period = 41;
 8001ab2:	2329      	movs	r3, #41	; 0x29
  htim3.Init.Prescaler = 0;
 8001ab4:	6074      	str	r4, [r6, #4]
  htim3.Init.Period = 41;
 8001ab6:	60f3      	str	r3, [r6, #12]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001ab8:	60b4      	str	r4, [r6, #8]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001aba:	6134      	str	r4, [r6, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001abc:	61b4      	str	r4, [r6, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8001abe:	f7ff f9df 	bl	8000e80 <HAL_TIM_Base_Init>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8001ac2:	2380      	movs	r3, #128	; 0x80
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8001ac4:	a906      	add	r1, sp, #24
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8001ac6:	015b      	lsls	r3, r3, #5
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8001ac8:	0030      	movs	r0, r6
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8001aca:	9306      	str	r3, [sp, #24]
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8001acc:	f7ff fc6a 	bl	80013a4 <HAL_TIM_ConfigClockSource>
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 8001ad0:	0030      	movs	r0, r6
 8001ad2:	f7ff fa49 	bl	8000f68 <HAL_TIM_PWM_Init>
  if (HAL_TIM_OnePulse_Init(&htim3, TIM_OPMODE_SINGLE) != HAL_OK)
 8001ad6:	2108      	movs	r1, #8
 8001ad8:	0030      	movs	r0, r6
 8001ada:	f7ff fab9 	bl	8001050 <HAL_TIM_OnePulse_Init>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8001ade:	a904      	add	r1, sp, #16
 8001ae0:	0030      	movs	r0, r6
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8001ae2:	9404      	str	r4, [sp, #16]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8001ae4:	9405      	str	r4, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8001ae6:	f7ff fd23 	bl	8001530 <HAL_TIMEx_MasterConfigSynchronization>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8001aea:	2360      	movs	r3, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8001aec:	2200      	movs	r2, #0
 8001aee:	0029      	movs	r1, r5
 8001af0:	0030      	movs	r0, r6
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8001af2:	930a      	str	r3, [sp, #40]	; 0x28
  sConfigOC.Pulse = 0;
 8001af4:	606c      	str	r4, [r5, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8001af6:	60ac      	str	r4, [r5, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8001af8:	612c      	str	r4, [r5, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8001afa:	f7ff fb25 	bl	8001148 <HAL_TIM_PWM_ConfigChannel>
  HAL_TIM_MspPostInit(&htim3);
 8001afe:	0030      	movs	r0, r6
 8001b00:	f000 f908 	bl	8001d14 <HAL_TIM_MspPostInit>
  htim3.Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8001b04:	2108      	movs	r1, #8
  htim3.Instance->CCER |= TIM_CCER_CC1E;
 8001b06:	6833      	ldr	r3, [r6, #0]
  huart2.Instance = USART2;
 8001b08:	4865      	ldr	r0, [pc, #404]	; (8001ca0 <main+0x2a4>)
  htim3.Instance->CCER |= TIM_CCER_CC1E;
 8001b0a:	6a1a      	ldr	r2, [r3, #32]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8001b0c:	6084      	str	r4, [r0, #8]
  htim3.Instance->CCER |= TIM_CCER_CC1E;
 8001b0e:	433a      	orrs	r2, r7
 8001b10:	621a      	str	r2, [r3, #32]
  htim3.Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8001b12:	699a      	ldr	r2, [r3, #24]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8001b14:	60c4      	str	r4, [r0, #12]
  htim3.Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8001b16:	430a      	orrs	r2, r1
 8001b18:	619a      	str	r2, [r3, #24]
  huart2.Instance = USART2;
 8001b1a:	4b62      	ldr	r3, [pc, #392]	; (8001ca4 <main+0x2a8>)
  huart2.Init.Parity = UART_PARITY_NONE;
 8001b1c:	6104      	str	r4, [r0, #16]
  huart2.Instance = USART2;
 8001b1e:	6003      	str	r3, [r0, #0]
  huart2.Init.BaudRate = 38400;
 8001b20:	2396      	movs	r3, #150	; 0x96
 8001b22:	021b      	lsls	r3, r3, #8
 8001b24:	6043      	str	r3, [r0, #4]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001b26:	230c      	movs	r3, #12
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001b28:	6184      	str	r4, [r0, #24]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001b2a:	6143      	str	r3, [r0, #20]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8001b2c:	61c4      	str	r4, [r0, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001b2e:	6204      	str	r4, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001b30:	6244      	str	r4, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8001b32:	f7ff fd87 	bl	8001644 <HAL_UART_Init>
		this->leds[i] = LED_NODE(red, green, blue);
 8001b36:	4b5c      	ldr	r3, [pc, #368]	; (8001ca8 <main+0x2ac>)
 8001b38:	495c      	ldr	r1, [pc, #368]	; (8001cac <main+0x2b0>)
 8001b3a:	4a5d      	ldr	r2, [pc, #372]	; (8001cb0 <main+0x2b4>)
	this->tim_ptr = tim_ptr;
 8001b3c:	606e      	str	r6, [r5, #4]
		this->leds[i] = LED_NODE(red, green, blue);
 8001b3e:	910d      	str	r1, [sp, #52]	; 0x34
 8001b40:	9110      	str	r1, [sp, #64]	; 0x40
 8001b42:	9113      	str	r1, [sp, #76]	; 0x4c
 8001b44:	9116      	str	r1, [sp, #88]	; 0x58
 8001b46:	9119      	str	r1, [sp, #100]	; 0x64
 8001b48:	911c      	str	r1, [sp, #112]	; 0x70
 8001b4a:	911f      	str	r1, [sp, #124]	; 0x7c
 8001b4c:	9122      	str	r1, [sp, #136]	; 0x88
 8001b4e:	9125      	str	r1, [sp, #148]	; 0x94
 8001b50:	9128      	str	r1, [sp, #160]	; 0xa0
 8001b52:	930c      	str	r3, [sp, #48]	; 0x30
 8001b54:	920e      	str	r2, [sp, #56]	; 0x38
 8001b56:	930f      	str	r3, [sp, #60]	; 0x3c
 8001b58:	9211      	str	r2, [sp, #68]	; 0x44
 8001b5a:	9312      	str	r3, [sp, #72]	; 0x48
 8001b5c:	9214      	str	r2, [sp, #80]	; 0x50
 8001b5e:	9315      	str	r3, [sp, #84]	; 0x54
 8001b60:	9217      	str	r2, [sp, #92]	; 0x5c
 8001b62:	9318      	str	r3, [sp, #96]	; 0x60
 8001b64:	921a      	str	r2, [sp, #104]	; 0x68
 8001b66:	931b      	str	r3, [sp, #108]	; 0x6c
 8001b68:	921d      	str	r2, [sp, #116]	; 0x74
 8001b6a:	931e      	str	r3, [sp, #120]	; 0x78
 8001b6c:	9220      	str	r2, [sp, #128]	; 0x80
 8001b6e:	9321      	str	r3, [sp, #132]	; 0x84
 8001b70:	9223      	str	r2, [sp, #140]	; 0x8c
 8001b72:	9324      	str	r3, [sp, #144]	; 0x90
 8001b74:	9226      	str	r2, [sp, #152]	; 0x98
 8001b76:	9327      	str	r3, [sp, #156]	; 0x9c
 8001b78:	9229      	str	r2, [sp, #164]	; 0xa4
 8001b7a:	932a      	str	r3, [sp, #168]	; 0xa8
 8001b7c:	912b      	str	r1, [sp, #172]	; 0xac
 8001b7e:	932d      	str	r3, [sp, #180]	; 0xb4
 8001b80:	9330      	str	r3, [sp, #192]	; 0xc0
 8001b82:	239c      	movs	r3, #156	; 0x9c
 8001b84:	922c      	str	r2, [sp, #176]	; 0xb0
 8001b86:	922f      	str	r2, [sp, #188]	; 0xbc
 8001b88:	4a4a      	ldr	r2, [pc, #296]	; (8001cb4 <main+0x2b8>)
 8001b8a:	912e      	str	r1, [sp, #184]	; 0xb8
  ledStrip.display();
 8001b8c:	0028      	movs	r0, r5
 8001b8e:	52ea      	strh	r2, [r5, r3]
	this->lastLedChanged = NUM_LEDS - 1;
 8001b90:	3b6b      	subs	r3, #107	; 0x6b
 8001b92:	802b      	strh	r3, [r5, #0]
 8001b94:	26c6      	movs	r6, #198	; 0xc6
 8001b96:	f7ff fed5 	bl	8001944 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv>
  HAL_Delay(5000);
 8001b9a:	4847      	ldr	r0, [pc, #284]	; (8001cb8 <main+0x2bc>)
 8001b9c:	f7fe fb70 	bl	8000280 <HAL_Delay>
 8001ba0:	446e      	add	r6, sp
	  for(int j = 0; j < 3; j++ )
 8001ba2:	2300      	movs	r3, #0
 8001ba4:	4698      	mov	r8, r3
 8001ba6:	3331      	adds	r3, #49	; 0x31
 8001ba8:	4699      	mov	r9, r3
	      for(int k = 0; k < 256; k++)
 8001baa:	2380      	movs	r3, #128	; 0x80
 8001bac:	005b      	lsls	r3, r3, #1
 8001bae:	2700      	movs	r7, #0
 8001bb0:	469a      	mov	sl, r3
	        switch(j)
 8001bb2:	4643      	mov	r3, r8
 8001bb4:	b2fa      	uxtb	r2, r7
 8001bb6:	2b01      	cmp	r3, #1
 8001bb8:	d05f      	beq.n	8001c7a <main+0x27e>
 8001bba:	2b02      	cmp	r3, #2
 8001bbc:	d155      	bne.n	8001c6a <main+0x26e>
 8001bbe:	ab0c      	add	r3, sp, #48	; 0x30
		this->leds[i] = LED_NODE(red, green, blue);
 8001bc0:	701c      	strb	r4, [r3, #0]
 8001bc2:	705c      	strb	r4, [r3, #1]
 8001bc4:	709a      	strb	r2, [r3, #2]
 8001bc6:	3303      	adds	r3, #3
	for(uint8_t i = 0; i < NUM_LEDS; i++)
 8001bc8:	429e      	cmp	r6, r3
 8001bca:	d1f9      	bne.n	8001bc0 <main+0x1c4>
	this->lastLedChanged = NUM_LEDS - 1;
 8001bcc:	464b      	mov	r3, r9
	        ledStrip.display();
 8001bce:	0028      	movs	r0, r5
 8001bd0:	802b      	strh	r3, [r5, #0]
	      for(int k = 0; k < 256; k++)
 8001bd2:	3701      	adds	r7, #1
	        ledStrip.display();
 8001bd4:	f7ff feb6 	bl	8001944 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv>
	        HAL_Delay(3);
 8001bd8:	2003      	movs	r0, #3
 8001bda:	f7fe fb51 	bl	8000280 <HAL_Delay>
	      for(int k = 0; k < 256; k++)
 8001bde:	4557      	cmp	r7, sl
 8001be0:	d1e7      	bne.n	8001bb2 <main+0x1b6>
 8001be2:	23fd      	movs	r3, #253	; 0xfd
 8001be4:	469a      	mov	sl, r3
	        switch(j)
 8001be6:	4643      	mov	r3, r8
 8001be8:	27fe      	movs	r7, #254	; 0xfe
 8001bea:	2b01      	cmp	r3, #1
 8001bec:	d01c      	beq.n	8001c28 <main+0x22c>
 8001bee:	2b02      	cmp	r3, #2
 8001bf0:	d133      	bne.n	8001c5a <main+0x25e>
 8001bf2:	ab0c      	add	r3, sp, #48	; 0x30
		this->leds[i] = LED_NODE(red, green, blue);
 8001bf4:	701c      	strb	r4, [r3, #0]
 8001bf6:	705c      	strb	r4, [r3, #1]
 8001bf8:	709f      	strb	r7, [r3, #2]
 8001bfa:	3303      	adds	r3, #3
	for(uint8_t i = 0; i < NUM_LEDS; i++)
 8001bfc:	429e      	cmp	r6, r3
 8001bfe:	d1f9      	bne.n	8001bf4 <main+0x1f8>
	this->lastLedChanged = NUM_LEDS - 1;
 8001c00:	464b      	mov	r3, r9
	        ledStrip.display();
 8001c02:	0028      	movs	r0, r5
 8001c04:	802b      	strh	r3, [r5, #0]
 8001c06:	f7ff fe9d 	bl	8001944 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv>
	        HAL_Delay(3);
 8001c0a:	2003      	movs	r0, #3
 8001c0c:	f7fe fb38 	bl	8000280 <HAL_Delay>
	      for(int k = 254; k >= 0; k--)
 8001c10:	4653      	mov	r3, sl
 8001c12:	3301      	adds	r3, #1
 8001c14:	d0c5      	beq.n	8001ba2 <main+0x1a6>
 8001c16:	2301      	movs	r3, #1
 8001c18:	425b      	negs	r3, r3
 8001c1a:	469c      	mov	ip, r3
 8001c1c:	18ff      	adds	r7, r7, r3
	        switch(j)
 8001c1e:	4643      	mov	r3, r8
 8001c20:	44e2      	add	sl, ip
 8001c22:	b2ff      	uxtb	r7, r7
 8001c24:	2b01      	cmp	r3, #1
 8001c26:	d1e2      	bne.n	8001bee <main+0x1f2>
 8001c28:	ab0c      	add	r3, sp, #48	; 0x30
		this->leds[i] = LED_NODE(red, green, blue);
 8001c2a:	701c      	strb	r4, [r3, #0]
 8001c2c:	705f      	strb	r7, [r3, #1]
 8001c2e:	709c      	strb	r4, [r3, #2]
 8001c30:	3303      	adds	r3, #3
	for(uint8_t i = 0; i < NUM_LEDS; i++)
 8001c32:	429e      	cmp	r6, r3
 8001c34:	d1f9      	bne.n	8001c2a <main+0x22e>
	this->lastLedChanged = NUM_LEDS - 1;
 8001c36:	464b      	mov	r3, r9
	        ledStrip.display();
 8001c38:	0028      	movs	r0, r5
 8001c3a:	802b      	strh	r3, [r5, #0]
 8001c3c:	f7ff fe82 	bl	8001944 <_ZN16LED_STRIP_WS2811ILt50EE7displayEv>
	        HAL_Delay(3);
 8001c40:	2003      	movs	r0, #3
 8001c42:	f7fe fb1d 	bl	8000280 <HAL_Delay>
	      for(int k = 254; k >= 0; k--)
 8001c46:	4653      	mov	r3, sl
 8001c48:	3301      	adds	r3, #1
 8001c4a:	d1e4      	bne.n	8001c16 <main+0x21a>
	  for(int j = 0; j < 3; j++ )
 8001c4c:	2301      	movs	r3, #1
 8001c4e:	469c      	mov	ip, r3
 8001c50:	44e0      	add	r8, ip
 8001c52:	4643      	mov	r3, r8
 8001c54:	2b03      	cmp	r3, #3
 8001c56:	d1a8      	bne.n	8001baa <main+0x1ae>
 8001c58:	e7a3      	b.n	8001ba2 <main+0x1a6>
 8001c5a:	ab0c      	add	r3, sp, #48	; 0x30
		this->leds[i] = LED_NODE(red, green, blue);
 8001c5c:	701f      	strb	r7, [r3, #0]
 8001c5e:	705c      	strb	r4, [r3, #1]
 8001c60:	709c      	strb	r4, [r3, #2]
 8001c62:	3303      	adds	r3, #3
	for(uint8_t i = 0; i < NUM_LEDS; i++)
 8001c64:	429e      	cmp	r6, r3
 8001c66:	d1f9      	bne.n	8001c5c <main+0x260>
 8001c68:	e7e5      	b.n	8001c36 <main+0x23a>
 8001c6a:	ab0c      	add	r3, sp, #48	; 0x30
		this->leds[i] = LED_NODE(red, green, blue);
 8001c6c:	701a      	strb	r2, [r3, #0]
 8001c6e:	705c      	strb	r4, [r3, #1]
 8001c70:	709c      	strb	r4, [r3, #2]
 8001c72:	3303      	adds	r3, #3
	for(uint8_t i = 0; i < NUM_LEDS; i++)
 8001c74:	429e      	cmp	r6, r3
 8001c76:	d1f9      	bne.n	8001c6c <main+0x270>
 8001c78:	e7a8      	b.n	8001bcc <main+0x1d0>
 8001c7a:	ab0c      	add	r3, sp, #48	; 0x30
		this->leds[i] = LED_NODE(red, green, blue);
 8001c7c:	701c      	strb	r4, [r3, #0]
 8001c7e:	705a      	strb	r2, [r3, #1]
 8001c80:	709c      	strb	r4, [r3, #2]
 8001c82:	3303      	adds	r3, #3
	for(uint8_t i = 0; i < NUM_LEDS; i++)
 8001c84:	429e      	cmp	r6, r3
 8001c86:	d1f9      	bne.n	8001c7c <main+0x280>
 8001c88:	e7a0      	b.n	8001bcc <main+0x1d0>
 8001c8a:	46c0      	nop			; (mov r8, r8)
 8001c8c:	40021000 	.word	0x40021000
 8001c90:	10210000 	.word	0x10210000
 8001c94:	48000800 	.word	0x48000800
 8001c98:	20000020 	.word	0x20000020
 8001c9c:	40000400 	.word	0x40000400
 8001ca0:	20000060 	.word	0x20000060
 8001ca4:	40004400 	.word	0x40004400
 8001ca8:	ffff00ff 	.word	0xffff00ff
 8001cac:	00ffff00 	.word	0x00ffff00
 8001cb0:	ff00ffff 	.word	0xff00ffff
 8001cb4:	ffffff00 	.word	0xffffff00
 8001cb8:	00001388 	.word	0x00001388

08001cbc <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001cbc:	2201      	movs	r2, #1
 8001cbe:	4b0a      	ldr	r3, [pc, #40]	; (8001ce8 <HAL_MspInit+0x2c>)
{
 8001cc0:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001cc2:	6999      	ldr	r1, [r3, #24]
 8001cc4:	4311      	orrs	r1, r2
 8001cc6:	6199      	str	r1, [r3, #24]
 8001cc8:	6999      	ldr	r1, [r3, #24]
 8001cca:	400a      	ands	r2, r1
  __HAL_RCC_PWR_CLK_ENABLE();
 8001ccc:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001cce:	9200      	str	r2, [sp, #0]
 8001cd0:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8001cd2:	69da      	ldr	r2, [r3, #28]
 8001cd4:	0549      	lsls	r1, r1, #21
 8001cd6:	430a      	orrs	r2, r1
 8001cd8:	61da      	str	r2, [r3, #28]
 8001cda:	69db      	ldr	r3, [r3, #28]
 8001cdc:	400b      	ands	r3, r1
 8001cde:	9301      	str	r3, [sp, #4]
 8001ce0:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001ce2:	b002      	add	sp, #8
 8001ce4:	4770      	bx	lr
 8001ce6:	46c0      	nop			; (mov r8, r8)
 8001ce8:	40021000 	.word	0x40021000

08001cec <HAL_TIM_Base_MspInit>:
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM3)
 8001cec:	4b07      	ldr	r3, [pc, #28]	; (8001d0c <HAL_TIM_Base_MspInit+0x20>)
 8001cee:	6802      	ldr	r2, [r0, #0]
{
 8001cf0:	b082      	sub	sp, #8
  if(htim_base->Instance==TIM3)
 8001cf2:	429a      	cmp	r2, r3
 8001cf4:	d108      	bne.n	8001d08 <HAL_TIM_Base_MspInit+0x1c>
  {
  /* USER CODE BEGIN TIM3_MspInit 0 */

  /* USER CODE END TIM3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM3_CLK_ENABLE();
 8001cf6:	2302      	movs	r3, #2
 8001cf8:	4a05      	ldr	r2, [pc, #20]	; (8001d10 <HAL_TIM_Base_MspInit+0x24>)
 8001cfa:	69d1      	ldr	r1, [r2, #28]
 8001cfc:	4319      	orrs	r1, r3
 8001cfe:	61d1      	str	r1, [r2, #28]
 8001d00:	69d2      	ldr	r2, [r2, #28]
 8001d02:	4013      	ands	r3, r2
 8001d04:	9301      	str	r3, [sp, #4]
 8001d06:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }

}
 8001d08:	b002      	add	sp, #8
 8001d0a:	4770      	bx	lr
 8001d0c:	40000400 	.word	0x40000400
 8001d10:	40021000 	.word	0x40021000

08001d14 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8001d14:	b510      	push	{r4, lr}
 8001d16:	0004      	movs	r4, r0
 8001d18:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001d1a:	2214      	movs	r2, #20
 8001d1c:	2100      	movs	r1, #0
 8001d1e:	a801      	add	r0, sp, #4
 8001d20:	f000 f8da 	bl	8001ed8 <memset>
  if(htim->Instance==TIM3)
 8001d24:	4b0d      	ldr	r3, [pc, #52]	; (8001d5c <HAL_TIM_MspPostInit+0x48>)
 8001d26:	6822      	ldr	r2, [r4, #0]
 8001d28:	429a      	cmp	r2, r3
 8001d2a:	d001      	beq.n	8001d30 <HAL_TIM_MspPostInit+0x1c>
  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }

}
 8001d2c:	b006      	add	sp, #24
 8001d2e:	bd10      	pop	{r4, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001d30:	2080      	movs	r0, #128	; 0x80
 8001d32:	4a0b      	ldr	r2, [pc, #44]	; (8001d60 <HAL_TIM_MspPostInit+0x4c>)
 8001d34:	0280      	lsls	r0, r0, #10
 8001d36:	6951      	ldr	r1, [r2, #20]
 8001d38:	4301      	orrs	r1, r0
 8001d3a:	6151      	str	r1, [r2, #20]
 8001d3c:	6953      	ldr	r3, [r2, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001d3e:	a901      	add	r1, sp, #4
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001d40:	4003      	ands	r3, r0
 8001d42:	9300      	str	r3, [sp, #0]
 8001d44:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8001d46:	2340      	movs	r3, #64	; 0x40
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001d48:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8001d4a:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001d4c:	3b3e      	subs	r3, #62	; 0x3e
 8001d4e:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001d50:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM3;
 8001d52:	3b01      	subs	r3, #1
 8001d54:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001d56:	f7fe faed 	bl	8000334 <HAL_GPIO_Init>
}
 8001d5a:	e7e7      	b.n	8001d2c <HAL_TIM_MspPostInit+0x18>
 8001d5c:	40000400 	.word	0x40000400
 8001d60:	40021000 	.word	0x40021000

08001d64 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8001d64:	b510      	push	{r4, lr}
 8001d66:	0004      	movs	r4, r0
 8001d68:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001d6a:	2214      	movs	r2, #20
 8001d6c:	2100      	movs	r1, #0
 8001d6e:	a803      	add	r0, sp, #12
 8001d70:	f000 f8b2 	bl	8001ed8 <memset>
  if(huart->Instance==USART2)
 8001d74:	4b11      	ldr	r3, [pc, #68]	; (8001dbc <HAL_UART_MspInit+0x58>)
 8001d76:	6822      	ldr	r2, [r4, #0]
 8001d78:	429a      	cmp	r2, r3
 8001d7a:	d001      	beq.n	8001d80 <HAL_UART_MspInit+0x1c>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 8001d7c:	b008      	add	sp, #32
 8001d7e:	bd10      	pop	{r4, pc}
    __HAL_RCC_USART2_CLK_ENABLE();
 8001d80:	2280      	movs	r2, #128	; 0x80
 8001d82:	4b0f      	ldr	r3, [pc, #60]	; (8001dc0 <HAL_UART_MspInit+0x5c>)
 8001d84:	0292      	lsls	r2, r2, #10
 8001d86:	69d9      	ldr	r1, [r3, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001d88:	2090      	movs	r0, #144	; 0x90
    __HAL_RCC_USART2_CLK_ENABLE();
 8001d8a:	4311      	orrs	r1, r2
 8001d8c:	61d9      	str	r1, [r3, #28]
 8001d8e:	69d9      	ldr	r1, [r3, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001d90:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_USART2_CLK_ENABLE();
 8001d92:	4011      	ands	r1, r2
 8001d94:	9101      	str	r1, [sp, #4]
 8001d96:	9901      	ldr	r1, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001d98:	6959      	ldr	r1, [r3, #20]
 8001d9a:	4311      	orrs	r1, r2
 8001d9c:	6159      	str	r1, [r3, #20]
 8001d9e:	695b      	ldr	r3, [r3, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001da0:	a903      	add	r1, sp, #12
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001da2:	401a      	ands	r2, r3
 8001da4:	9202      	str	r2, [sp, #8]
 8001da6:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
 8001da8:	230c      	movs	r3, #12
 8001daa:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001dac:	3b0a      	subs	r3, #10
 8001dae:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF1_USART2;
 8001db0:	3b01      	subs	r3, #1
 8001db2:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001db4:	f7fe fabe 	bl	8000334 <HAL_GPIO_Init>
}
 8001db8:	e7e0      	b.n	8001d7c <HAL_UART_MspInit+0x18>
 8001dba:	46c0      	nop			; (mov r8, r8)
 8001dbc:	40004400 	.word	0x40004400
 8001dc0:	40021000 	.word	0x40021000

08001dc4 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8001dc4:	4770      	bx	lr
 8001dc6:	46c0      	nop			; (mov r8, r8)

08001dc8 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8001dc8:	e7fe      	b.n	8001dc8 <HardFault_Handler>
 8001dca:	46c0      	nop			; (mov r8, r8)

08001dcc <SVC_Handler>:
 8001dcc:	4770      	bx	lr
 8001dce:	46c0      	nop			; (mov r8, r8)

08001dd0 <PendSV_Handler>:
 8001dd0:	4770      	bx	lr
 8001dd2:	46c0      	nop			; (mov r8, r8)

08001dd4 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8001dd4:	b510      	push	{r4, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001dd6:	f7fe fa45 	bl	8000264 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8001dda:	bd10      	pop	{r4, pc}

08001ddc <SystemInit>:
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001U;
 8001ddc:	2101      	movs	r1, #1
 8001dde:	4b11      	ldr	r3, [pc, #68]	; (8001e24 <SystemInit+0x48>)
#if defined (STM32F051x8) || defined (STM32F058x8)
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80CU;
#else
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8001de0:	4811      	ldr	r0, [pc, #68]	; (8001e28 <SystemInit+0x4c>)
  RCC->CR |= (uint32_t)0x00000001U;
 8001de2:	681a      	ldr	r2, [r3, #0]
 8001de4:	430a      	orrs	r2, r1
 8001de6:	601a      	str	r2, [r3, #0]
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8001de8:	685a      	ldr	r2, [r3, #4]
 8001dea:	4002      	ands	r2, r0
 8001dec:	605a      	str	r2, [r3, #4]
#endif /* STM32F051x8 or STM32F058x8 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFFU;
 8001dee:	681a      	ldr	r2, [r3, #0]
 8001df0:	480e      	ldr	r0, [pc, #56]	; (8001e2c <SystemInit+0x50>)
 8001df2:	4002      	ands	r2, r0
 8001df4:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFFU;
 8001df6:	681a      	ldr	r2, [r3, #0]
 8001df8:	480d      	ldr	r0, [pc, #52]	; (8001e30 <SystemInit+0x54>)
 8001dfa:	4002      	ands	r2, r0
 8001dfc:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 8001dfe:	685a      	ldr	r2, [r3, #4]
 8001e00:	480c      	ldr	r0, [pc, #48]	; (8001e34 <SystemInit+0x58>)
 8001e02:	4002      	ands	r2, r0

  /* Reset PREDIV[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8001e04:	200f      	movs	r0, #15
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 8001e06:	605a      	str	r2, [r3, #4]
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8001e08:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001e0a:	4382      	bics	r2, r0
 8001e0c:	62da      	str	r2, [r3, #44]	; 0x2c

#if defined (STM32F072xB) || defined (STM32F078xx)
  /* Reset USART2SW[1:0], USART1SW[1:0], I2C1SW, CECSW, USBSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFCFE2CU;
 8001e0e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001e10:	4809      	ldr	r0, [pc, #36]	; (8001e38 <SystemInit+0x5c>)
 8001e12:	4002      	ands	r2, r0
 8001e14:	631a      	str	r2, [r3, #48]	; 0x30
#else
 #warning "No target selected"
#endif

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFEU;
 8001e16:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001e18:	438a      	bics	r2, r1
 8001e1a:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000U;
 8001e1c:	2200      	movs	r2, #0
 8001e1e:	609a      	str	r2, [r3, #8]

}
 8001e20:	4770      	bx	lr
 8001e22:	46c0      	nop			; (mov r8, r8)
 8001e24:	40021000 	.word	0x40021000
 8001e28:	08ffb80c 	.word	0x08ffb80c
 8001e2c:	fef6ffff 	.word	0xfef6ffff
 8001e30:	fffbffff 	.word	0xfffbffff
 8001e34:	ffc0ffff 	.word	0xffc0ffff
 8001e38:	fffcfe2c 	.word	0xfffcfe2c

08001e3c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8001e3c:	480d      	ldr	r0, [pc, #52]	; (8001e74 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8001e3e:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8001e40:	480d      	ldr	r0, [pc, #52]	; (8001e78 <LoopForever+0x6>)
  ldr r1, =_edata
 8001e42:	490e      	ldr	r1, [pc, #56]	; (8001e7c <LoopForever+0xa>)
  ldr r2, =_sidata
 8001e44:	4a0e      	ldr	r2, [pc, #56]	; (8001e80 <LoopForever+0xe>)
  movs r3, #0
 8001e46:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001e48:	e002      	b.n	8001e50 <LoopCopyDataInit>

08001e4a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001e4a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001e4c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001e4e:	3304      	adds	r3, #4

08001e50 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001e50:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001e52:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001e54:	d3f9      	bcc.n	8001e4a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001e56:	4a0b      	ldr	r2, [pc, #44]	; (8001e84 <LoopForever+0x12>)
  ldr r4, =_ebss
 8001e58:	4c0b      	ldr	r4, [pc, #44]	; (8001e88 <LoopForever+0x16>)
  movs r3, #0
 8001e5a:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001e5c:	e001      	b.n	8001e62 <LoopFillZerobss>

08001e5e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001e5e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001e60:	3204      	adds	r2, #4

08001e62 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001e62:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001e64:	d3fb      	bcc.n	8001e5e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8001e66:	f7ff ffb9 	bl	8001ddc <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8001e6a:	f000 f811 	bl	8001e90 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8001e6e:	f7ff fdc5 	bl	80019fc <main>

08001e72 <LoopForever>:

LoopForever:
    b LoopForever
 8001e72:	e7fe      	b.n	8001e72 <LoopForever>
  ldr   r0, =_estack
 8001e74:	20004000 	.word	0x20004000
  ldr r0, =_sdata
 8001e78:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001e7c:	20000004 	.word	0x20000004
  ldr r2, =_sidata
 8001e80:	08001f44 	.word	0x08001f44
  ldr r2, =_sbss
 8001e84:	20000004 	.word	0x20000004
  ldr r4, =_ebss
 8001e88:	200000d4 	.word	0x200000d4

08001e8c <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001e8c:	e7fe      	b.n	8001e8c <ADC1_COMP_IRQHandler>
	...

08001e90 <__libc_init_array>:
 8001e90:	b570      	push	{r4, r5, r6, lr}
 8001e92:	2600      	movs	r6, #0
 8001e94:	4d0c      	ldr	r5, [pc, #48]	; (8001ec8 <__libc_init_array+0x38>)
 8001e96:	4c0d      	ldr	r4, [pc, #52]	; (8001ecc <__libc_init_array+0x3c>)
 8001e98:	1b64      	subs	r4, r4, r5
 8001e9a:	10a4      	asrs	r4, r4, #2
 8001e9c:	42a6      	cmp	r6, r4
 8001e9e:	d109      	bne.n	8001eb4 <__libc_init_array+0x24>
 8001ea0:	2600      	movs	r6, #0
 8001ea2:	f000 f821 	bl	8001ee8 <_init>
 8001ea6:	4d0a      	ldr	r5, [pc, #40]	; (8001ed0 <__libc_init_array+0x40>)
 8001ea8:	4c0a      	ldr	r4, [pc, #40]	; (8001ed4 <__libc_init_array+0x44>)
 8001eaa:	1b64      	subs	r4, r4, r5
 8001eac:	10a4      	asrs	r4, r4, #2
 8001eae:	42a6      	cmp	r6, r4
 8001eb0:	d105      	bne.n	8001ebe <__libc_init_array+0x2e>
 8001eb2:	bd70      	pop	{r4, r5, r6, pc}
 8001eb4:	00b3      	lsls	r3, r6, #2
 8001eb6:	58eb      	ldr	r3, [r5, r3]
 8001eb8:	4798      	blx	r3
 8001eba:	3601      	adds	r6, #1
 8001ebc:	e7ee      	b.n	8001e9c <__libc_init_array+0xc>
 8001ebe:	00b3      	lsls	r3, r6, #2
 8001ec0:	58eb      	ldr	r3, [r5, r3]
 8001ec2:	4798      	blx	r3
 8001ec4:	3601      	adds	r6, #1
 8001ec6:	e7f2      	b.n	8001eae <__libc_init_array+0x1e>
 8001ec8:	08001f3c 	.word	0x08001f3c
 8001ecc:	08001f3c 	.word	0x08001f3c
 8001ed0:	08001f3c 	.word	0x08001f3c
 8001ed4:	08001f40 	.word	0x08001f40

08001ed8 <memset>:
 8001ed8:	0003      	movs	r3, r0
 8001eda:	1812      	adds	r2, r2, r0
 8001edc:	4293      	cmp	r3, r2
 8001ede:	d100      	bne.n	8001ee2 <memset+0xa>
 8001ee0:	4770      	bx	lr
 8001ee2:	7019      	strb	r1, [r3, #0]
 8001ee4:	3301      	adds	r3, #1
 8001ee6:	e7f9      	b.n	8001edc <memset+0x4>

08001ee8 <_init>:
 8001ee8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001eea:	46c0      	nop			; (mov r8, r8)
 8001eec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001eee:	bc08      	pop	{r3}
 8001ef0:	469e      	mov	lr, r3
 8001ef2:	4770      	bx	lr

08001ef4 <_fini>:
 8001ef4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001ef6:	46c0      	nop			; (mov r8, r8)
 8001ef8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001efa:	bc08      	pop	{r3}
 8001efc:	469e      	mov	lr, r3
 8001efe:	4770      	bx	lr
